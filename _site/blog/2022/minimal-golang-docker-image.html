<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>Minimal Golang Docker image - Daniel Oltmanns</title>

    <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Minimal Golang Docker image | Daniel Oltmanns</title>
<meta name="generator" content="Jekyll v4.3.2" />
<meta property="og:title" content="Minimal Golang Docker image" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="As golang is a compiled programming language, we don’t need to store all the unecessary build environments in our final image. So lets see, if we get rid of everything, what we need to importat again to not break anything." />
<meta property="og:description" content="As golang is a compiled programming language, we don’t need to store all the unecessary build environments in our final image. So lets see, if we get rid of everything, what we need to importat again to not break anything." />
<link rel="canonical" href="https://oltdaniel.eu/blog/2022/minimal-golang-docker-image.html" />
<meta property="og:url" content="https://oltdaniel.eu/blog/2022/minimal-golang-docker-image.html" />
<meta property="og:site_name" content="Daniel Oltmanns" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-01-04T00:00:00+01:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Minimal Golang Docker image" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-01-04T00:00:00+01:00","datePublished":"2022-01-04T00:00:00+01:00","description":"As golang is a compiled programming language, we don’t need to store all the unecessary build environments in our final image. So lets see, if we get rid of everything, what we need to importat again to not break anything.","headline":"Minimal Golang Docker image","mainEntityOfPage":{"@type":"WebPage","@id":"https://oltdaniel.eu/blog/2022/minimal-golang-docker-image.html"},"url":"https://oltdaniel.eu/blog/2022/minimal-golang-docker-image.html"}</script>
<!-- End Jekyll SEO tag -->


    <link media="all" rel="stylesheet" href="/assets/fonts/inter.css">
    <link media="all" rel="stylesheet" href="/assets/style.css">
</head>
<body>
    <header>
    <h1>Daniel Oltmanns</h1>

    
    <p>personal blog and collection of tips</p>
    

    <nav>
        
        <a href="/" >About</a>
        
        <a href="/blog" >Blog</a>
        
        <a href="/tips" >Tips</a>
        
    </nav>
</header>

<main>
<article>
    <h2>Minimal Golang Docker image</h2>
    <time>2022-01-04</time>

    <p>As golang is a compiled programming language, we don’t need to store all the unecessary build environments in our final image. So lets see, if we get rid of everything, what we need to importat again to not break anything.</p>

<p>In order to solve everything in a single <code class="language-plaintext highlighter-rouge">Dockerfile</code>, we will use multi-stage builds. <sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup> Our first stage will be focused on the actual compiling of our application. In order to cover as many features on our application as possible, I’ll create an API that uses timezone information, calls an external service via https and uses the lua shared library.</p>

<h2 id="project-setup">Project setup</h2>

<p>First we create a new folder and initialize our dependecy manager and load some dependencies.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>go mod init github.com/oltdaniel/golang-minimal-docker
<span class="c"># we will use gin as our webserver</span>
go get github.com/gin-gonic/gin
<span class="c"># and a lua binding</span>
go get github.com/aarzilli/golua/lua
</code></pre></div></div>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"io"</span>
	<span class="s">"log"</span>
	<span class="s">"net/http"</span>
	<span class="s">"time"</span>

	<span class="s">"github.com/aarzilli/golua/lua"</span>
	<span class="s">"github.com/gin-gonic/gin"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">s</span> <span class="o">:=</span> <span class="n">gin</span><span class="o">.</span><span class="n">Default</span><span class="p">()</span>

	<span class="c">// call another api via https</span>
	<span class="c">// this will require ca-certificates</span>
	<span class="c">// for veriying the ssl certificate</span>
	<span class="n">s</span><span class="o">.</span><span class="n">GET</span><span class="p">(</span><span class="s">"/ip"</span><span class="p">,</span> <span class="k">func</span><span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">gin</span><span class="o">.</span><span class="n">Context</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">resp</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">http</span><span class="o">.</span><span class="n">Get</span><span class="p">(</span><span class="s">"https://api.ipify.org"</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
			<span class="n">log</span><span class="o">.</span><span class="n">Fatal</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="n">c</span><span class="o">.</span><span class="n">Status</span><span class="p">(</span><span class="n">resp</span><span class="o">.</span><span class="n">StatusCode</span><span class="p">)</span>
		<span class="n">io</span><span class="o">.</span><span class="n">Copy</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">Writer</span><span class="p">,</span> <span class="n">resp</span><span class="o">.</span><span class="n">Body</span><span class="p">)</span>
	<span class="p">})</span>

	<span class="c">// convert some stuff within the timezones</span>
	<span class="c">// this will require the timezone data</span>
	<span class="n">s</span><span class="o">.</span><span class="n">GET</span><span class="p">(</span><span class="s">"/time"</span><span class="p">,</span> <span class="k">func</span><span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">gin</span><span class="o">.</span><span class="n">Context</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">wantedTimeLocation</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">time</span><span class="o">.</span><span class="n">LoadLocation</span><span class="p">(</span><span class="s">"Asia/Tokyo"</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
			<span class="n">log</span><span class="o">.</span><span class="n">Fatal</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="n">c</span><span class="o">.</span><span class="n">String</span><span class="p">(</span>
      <span class="m">200</span><span class="p">,</span>
      <span class="s">"server time in japan would be %v"</span><span class="p">,</span>
      <span class="n">time</span><span class="o">.</span><span class="n">Now</span><span class="p">()</span><span class="o">.</span><span class="n">In</span><span class="p">(</span><span class="n">wantedTimeLocation</span><span class="p">)</span><span class="o">.</span><span class="n">String</span><span class="p">())</span>
	<span class="p">})</span>

	<span class="c">// here we create a lua machine</span>
	<span class="c">// register a custom response function</span>
	<span class="c">// and execute the response directly from within the lua machine</span>
	<span class="c">// this will require the use of the lua library</span>
	<span class="n">s</span><span class="o">.</span><span class="n">GET</span><span class="p">(</span><span class="s">"/lua"</span><span class="p">,</span> <span class="k">func</span><span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">gin</span><span class="o">.</span><span class="n">Context</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lmachine</span> <span class="o">:=</span> <span class="n">lua</span><span class="o">.</span><span class="n">NewState</span><span class="p">()</span>
		<span class="k">defer</span> <span class="n">lmachine</span><span class="o">.</span><span class="n">Close</span><span class="p">()</span>

		<span class="n">lmachine</span><span class="o">.</span><span class="n">Register</span><span class="p">(</span><span class="s">"response"</span><span class="p">,</span> <span class="k">func</span><span class="p">(</span><span class="n">ls</span> <span class="o">*</span><span class="n">lua</span><span class="o">.</span><span class="n">State</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
			<span class="n">resp</span> <span class="o">:=</span> <span class="n">ls</span><span class="o">.</span><span class="n">ToString</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>
			<span class="n">c</span><span class="o">.</span><span class="n">String</span><span class="p">(</span><span class="m">200</span><span class="p">,</span> <span class="n">resp</span><span class="p">)</span>
			<span class="k">return</span> <span class="m">1</span>
		<span class="p">})</span>

		<span class="n">err</span> <span class="o">:=</span> <span class="n">lmachine</span><span class="o">.</span><span class="n">DoString</span><span class="p">(</span><span class="s">"response 'hello world'"</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
			<span class="n">log</span><span class="o">.</span><span class="n">Fatal</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">})</span>

	<span class="n">s</span><span class="o">.</span><span class="n">Run</span><span class="p">(</span><span class="s">":3001"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="first-stage">First stage</h2>

<div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># use a fully featured golang build environment</span>
<span class="k">FROM</span><span class="w"> </span><span class="s">golang:latest</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="s">builder</span>
<span class="c"># install project dependencies</span>
<span class="k">RUN </span>apt update <span class="o">&amp;&amp;</span> apt <span class="nb">install</span> <span class="nt">-y</span> liblua5.1
<span class="c"># select a space for our work</span>
<span class="k">WORKDIR</span><span class="s"> /app</span>
<span class="c"># copy dependency files</span>
<span class="k">COPY</span><span class="s"> go.mod .</span>
<span class="k">COPY</span><span class="s"> go.sum .</span>
<span class="c"># install dependencies</span>
<span class="k">RUN </span>go mod download
<span class="c"># copy everything else</span>
<span class="k">COPY</span><span class="s"> . .</span>
<span class="c"># compile our golang project</span>
<span class="k">RUN </span><span class="nv">GOOS</span><span class="o">=</span>linux go build <span class="nt">-a</span> main.go
<span class="c"># expose e.g. a API port</span>
<span class="k">EXPOSE</span><span class="s"> 3001</span>
<span class="c"># start our application if no exec command given</span>
<span class="k">CMD</span><span class="s"> ["/app/main"]</span>
</code></pre></div></div>
<p>At this point, we don’t really care about the image size at all. We can utilize all tools we require in our build environment due to the default debian system. The order of the build steps are essential at this point, if you want to reduce the number of total steps that need to be execute during a new build of the image.</p>

<ol>
  <li>Install any system wide packages that are required via <code class="language-plaintext highlighter-rouge">apt</code>.</li>
  <li>Specify your work environment and install only the project related dependencies.</li>
  <li>Copy the actual source code of you application.</li>
  <li>Compile everything.</li>
</ol>

<p>It is important to note here, that the use of <code class="language-plaintext highlighter-rouge">.dockerignore</code> will also help to reduce the build steps, as the <code class="language-plaintext highlighter-rouge">COPY . .</code> step will be executed again, if anything in the project folder changed, that is not marked to be ignored in the <code class="language-plaintext highlighter-rouge">.dockerignore</code> file.</p>

<p>The image we have here is a total of <code class="language-plaintext highlighter-rouge">1.19GB</code>.</p>

<h2 id="second-stage">Second stage</h2>

<p>The second stage can be split into to different approaches, which will both result in changes of our first stage. You need to ask yourself now, whether your project has any direct usage of non-go libraries. An example for this can be the use of the shared lua library for some embedded scripting functionalities. In general, if you don’t really known how your libraries work under the hood or just have too many to check them manually, you can simply try to compile them with both approaches and test it. The <code class="language-plaintext highlighter-rouge">scratch</code> image with not dependencies at all will however be smaller.</p>

<h3 id="second-stage-for-system-libraries">Second stage: For system libraries</h3>

<p>Compiling everything into a static library or even into the executable itself can be really difficult and heavily depends on the implementation of dependecy owner. For a better developer experience I would suggest to make use of the <code class="language-plaintext highlighter-rouge">alpine</code> linux image. It is very minimal, but still comes with a huge selection of packages that can be installed. As the Golang docker image also supports and alpine image, I suggest we use that, as especially the libraries we may require, will be exactly the same between the first and second stage, which reduces the number of bugs we may run into, like different package names.</p>

<p>So lets rebuild the first stage and add the second one. In my example I’ll use the <code class="language-plaintext highlighter-rouge">golua</code><sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup> package which requires the shared library of lua.</p>

<div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># first stage for our compiling environment</span>
<span class="k">FROM</span><span class="w"> </span><span class="s">golang:alpine</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="s">builder</span>
<span class="c"># install build tools</span>
<span class="k">RUN </span>apk add <span class="nt">--no-cache</span> build-base
<span class="c"># install libraries</span>
<span class="k">RUN </span>apk add <span class="nt">--no-cache</span> lua5.1-dev
<span class="c"># select a space for our work</span>
<span class="k">WORKDIR</span><span class="s"> /app</span>
<span class="c"># copy dependency files</span>
<span class="k">COPY</span><span class="s"> go.mod .</span>
<span class="k">COPY</span><span class="s"> go.sum .</span>
<span class="c"># install dependencies</span>
<span class="k">RUN </span>go mod download
<span class="c"># copy everything else</span>
<span class="k">COPY</span><span class="s"> . .</span>
<span class="c"># compile our golang project</span>
<span class="k">RUN </span><span class="nv">GOOS</span><span class="o">=</span>linux go build <span class="nt">-a</span> main.go

<span class="c"># second stage that will actually be published/deployed</span>
<span class="k">FROM</span><span class="s"> alpine</span>
<span class="c"># install timezone and certificate files</span>
<span class="k">RUN </span>apk add <span class="nt">--no-cache</span> tzdata ca-certificates
<span class="c"># install libraries</span>
<span class="k">RUN </span>apk add <span class="nt">--no-cache</span> lua5.1-dev
<span class="c"># copy our binary</span>
<span class="k">COPY</span><span class="s"> --from=builder /app/main /</span>
<span class="c"># expose e.g. a API port</span>
<span class="k">EXPOSE</span><span class="s"> 3001</span>
<span class="c"># start our application if no exec command given</span>
<span class="k">CMD</span><span class="s"> ["/main"]</span>
</code></pre></div></div>

<p>This results in an <code class="language-plaintext highlighter-rouge">18MB</code> docker image.</p>

<h3 id="second-stage-just-the-basics">Second stage: Just the basics</h3>

<p>If your project is focused on only in go written depencies and doesn’t cause any problems if you strip away everything from the OS itself.</p>

<blockquote>
  <p>As an example I use the same project, but removed the lua functionality due to the bindings.</p>
</blockquote>

<p>For this, we don’t care about the first stage as we did before. It can be as big as you like, as nothing will be deployed later on and we don’t need to worry about any system libraries. In order to ensure that we don’t run into any issues with out compiled binary, we need to make sure, the go compiler knows that the binary won’t have any access to the current libraries later on. For this we can utilize the compiler flags use in the multistage example of the docker documentation. <sup id="fnref:1:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">CGO_ENABLED=0</code> will tell the go compiler, it doesn’t have access to any system libraries.</li>
  <li>however, the <code class="language-plaintext highlighter-rouge">-installsuffix cgo</code> argument is <strong>not required anymore</strong> as stated in the original GitHub issue about static linking issues. <sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup></li>
</ul>

<div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># use a fully featured golang build environment</span>
<span class="k">FROM</span><span class="w"> </span><span class="s">golang:latest</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="s">builder</span>
<span class="c"># change directory of project</span>
<span class="k">WORKDIR</span><span class="s"> /app</span>
<span class="c"># copy everything else</span>
<span class="k">COPY</span><span class="s"> . .</span>
<span class="c"># compile our golang project</span>
<span class="k">RUN </span><span class="nv">CGO_ENABLED</span><span class="o">=</span>0 <span class="nv">GOOS</span><span class="o">=</span>linux go build <span class="nt">-o</span> main  .

<span class="k">FROM</span><span class="s"> scratch</span>
<span class="c"># copy ca certificates to verify other ssl certificates</span>
<span class="k">COPY</span><span class="s"> --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/ca-certificates.crt</span>
<span class="c"># copy timezone information</span>
<span class="k">COPY</span><span class="s"> --from=builder /usr/share/zoneinfo /usr/share/zoneinfo</span>
<span class="c"># copy actual compiled binary</span>
<span class="k">COPY</span><span class="s"> --from=builder /app/main /</span>
<span class="c"># expose port</span>
<span class="k">EXPOSE</span><span class="s"> 3001</span>
<span class="c"># start binary</span>
<span class="k">CMD</span><span class="s"> ["/main"]</span>
</code></pre></div></div>

<p>This results in an <code class="language-plaintext highlighter-rouge">11.7MB</code> docker image. But we got rid of the shared lua library which was a essential function of our project.</p>

<p>However, there are a lot of projects out there, that port shared library projects to a pure golang version. However, finding bindings for a package you want to you, is way easier. Additionally, many projects like simple APIs don’t actually require any bindings at all, <strong>especially if you require new versions of certain projects</strong>.</p>

<h2 id="result">Result</h2>

<h3 id="full-image-119gb">full image <code class="language-plaintext highlighter-rouge">1.19GB</code></h3>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gd">- extremly large size
- lot of overhead for running this container
</span><span class="gi">+ easy dependency management
+ similar to many developer environments
</span></code></pre></div></div>

<h3 id="alpine-image-18mb">alpine image <code class="language-plaintext highlighter-rouge">18MB</code></h3>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gd">- package names can be different
- more initial work to find all missing dependencies
</span><span class="gi">+ well supported and documented
+ very small image and overhead
</span></code></pre></div></div>

<h3 id="scratch-image-117mb">scratch image <code class="language-plaintext highlighter-rouge">11.7MB</code></h3>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gd">- no usage of complex dependencies
- no system commands (ls, chmod, ...)
</span><span class="gi">+ perfect for small projects
+ runs only what you want
</span></code></pre></div></div>

<h2 id="final-word">Final word</h2>

<p>Again, the choice is up to you. Every option I listed has nearly equal pros and cons and what speaks most to you or to your project can be different. I personally always suggest to take a look at alpine images and maybe your project can be up and running in a much smaller image with just a few lines of changes.</p>

<p>However, even though scratch images look like a nice thing, it breaks things more often than it actually improves it. So I only suggest this type of image, if you really just have a minimal static binary that needs to be honest and doesn’t have any complex dependencies into the system libraries.</p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>docker docs “multistage build”: <a href="https://docs.docker.com/develop/develop-images/multistage-build/"><code class="language-plaintext highlighter-rouge">docs.docker.com/develop/develop-images/multistage-build</code></a> <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:1:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>GitHub <code class="language-plaintext highlighter-rouge">golua</code>: <a href="https://github.com/aarzilli/golua"><code class="language-plaintext highlighter-rouge">github.com/aarzilli/golua</code></a> <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>GitHub comment about newer golang versions and static linking: <a href="https://github.com/golang/go/issues/9344#issuecomment-69944514"><code class="language-plaintext highlighter-rouge">github.com/golang/go/issues/9344#issuecomment-69944514</code></a> <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

</article>
</main>

<footer>
    <p>Copyright &copy; 2023 Daniel Oltmanns.</p>
    <p>All Rights Reserved.</p>
</footer>
</body>
</html>