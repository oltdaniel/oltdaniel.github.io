<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>Counting Instead of Tracking - Daniel Oltmanns</title>

    <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Counting Instead of Tracking | Daniel Oltmanns</title>
<meta name="generator" content="Jekyll v4.3.2" />
<meta property="og:title" content="Counting Instead of Tracking" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Analyzing the traffic a website receives, is a key part in marketing to understand and highlight the group of consumers and their interests. However, the way how it has been implemented in the recent years has evolved from counting single requests to tracking the use across multiple websites." />
<meta property="og:description" content="Analyzing the traffic a website receives, is a key part in marketing to understand and highlight the group of consumers and their interests. However, the way how it has been implemented in the recent years has evolved from counting single requests to tracking the use across multiple websites." />
<link rel="canonical" href="https://oltdaniel.eu/blog/2018/counting-instead-of-tracking.html" />
<meta property="og:url" content="https://oltdaniel.eu/blog/2018/counting-instead-of-tracking.html" />
<meta property="og:site_name" content="Daniel Oltmanns" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-11-15T00:00:00+01:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Counting Instead of Tracking" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2018-11-15T00:00:00+01:00","datePublished":"2018-11-15T00:00:00+01:00","description":"Analyzing the traffic a website receives, is a key part in marketing to understand and highlight the group of consumers and their interests. However, the way how it has been implemented in the recent years has evolved from counting single requests to tracking the use across multiple websites.","headline":"Counting Instead of Tracking","mainEntityOfPage":{"@type":"WebPage","@id":"https://oltdaniel.eu/blog/2018/counting-instead-of-tracking.html"},"url":"https://oltdaniel.eu/blog/2018/counting-instead-of-tracking.html"}</script>
<!-- End Jekyll SEO tag -->


    <link media="all" rel="stylesheet" href="/assets/fonts/inter.css">
    <link media="all" rel="stylesheet" href="/assets/style.css">
</head>
<body>
    <header>
    <h1>Daniel Oltmanns</h1>

    
    <p>personal blog and collection of tips</p>
    

    <nav>
        
        <a href="/" >About</a>
        
        <a href="/blog" >Blog</a>
        
        <a href="/tips" >Tips</a>
        
    </nav>
</header>

<main>
<article>
    <h2>Counting Instead of Tracking</h2>
    <time>2018-11-15</time>

    <p>Analyzing the traffic a website receives, is a key part in marketing to
understand and highlight the group of consumers and their interests. However,
the way how it has been implemented in the recent years has evolved from
counting single requests to tracking the use across multiple websites.</p>

<p>For a short moment I decided against this trend and went back to the old
classics of website analysis. I start counting the unique requests, instead of
tracking the user across our website. You may ask yourself now, what the
motivation behind this solution is. First, I hate cookie banners. Every site
we will request, will have an huge cookie banner explaining how our data will
be used on the current site I am viewing. Secondly, I love minimalistic
solutions that will solve our problem in just a view lines of code.</p>

<p>Therefore, I will follow certain rules in our solution in order to deliver a
minimalistic, and privacy protective solution to the user devices with a low
bandwidth usage. How I will receive the visitors data is limited to a simple
resource loading procedure by the browser, which means, I will not use
JavaScript in order to collect and send the data that is required on the server
side. Additionally, our solution is not allowed to store data on the client
device, e.g. cookies, as I do not want to have any kind of cookie banner on our
website.</p>

<ol>
  <li>No JavaScript is allowed, the data needs to be sent by the browser itself.</li>
  <li>As of 1., I am not able to extract any extra information from the client
device and are limited to the HTTP request only.</li>
  <li>A low bandwidth will be automatically achieved, as I do not need to send
any return body, nor is the server required to send any scripts to the client
that are responsible for the data collection and sending procedure.</li>
</ol>

<h3 id="meta-data">Meta-data</h3>

<p>The way of making the request is now done. But I need to decided on the
information I will extract from the HTTP headers or can be extracted from the
raw TCP request behind the HTTP protocol. This can be classified as meta-data.
As I specified in the goal before, I do not want to store that kind of data as
raw data on our server. However, I need some visitor specific data, that I can
use in order to identify a unique user.</p>

<p>Storing an random unique id on the user device as an cookie would have many
advantages at this point, as it will allow us to be completely independent from
the user meta-data and count unique page views as long as the cookie is not
expired. However, I hate cookie banners, so on this kind of solution violates
the rule of our solution.</p>

<ul>
  <li><strong>Referer</strong>: The Referer HTTP header will be delivered with the root url
the user requested, of which the received request on our server is a subordinate
request.</li>
  <li><strong>IP address</strong>: Each request will be started by a visitors device having an
IP address. I will use this, in order to identify the users device with an
unique value.</li>
  <li><strong>User-Agent</strong>: Multiple browsers are available on the market with
different versions and browser engines. As this setting is not totally unique,
it needs to be combined with another information.</li>
</ul>

<h3 id="storing-data">Storing data</h3>

<p>Having specified the data I am able to extract from the HTTP request, I need
to combine this data, in order to be privacy protective and unique. Another
aspect I need to add at this point, is the fact I do not want to store these
informations in raw format on our server.</p>

<p>Lets start with the privacy protective part, that I want in our solution. The
data that is privacy relevant in the meta-data I have collect within the HTTP
request is the IP address. A way of partly anonymizing it is removing the last
part of the IP address, e.g. <code class="language-plaintext highlighter-rouge">1.1.1.1</code> will become <code class="language-plaintext highlighter-rouge">1.1.1</code>.<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup> This procedure is also known as IP masking. This
will merge 256 different IP addresses to the same id, but 256 of 2^32 isn’t that
much. However doing this will rise the privacy level.</p>

<p>More privacy means less uniqueness in the most cases, if nothing will be stored
on the client device in order to represent an identity. This is a common problem
with using a single value as an identifier. So let us try merging multiple
values together.</p>

<p>Looking back into the list of meta-data I have collected from the HTTP request,
we can use the <code class="language-plaintext highlighter-rouge">User-Agent</code> header in order to rise the level of uniqueness we
slightly shrank in the last step. By merging the reaming IP address and the
user agent of the specific user, I assigned a specific browser to a specific
client. A partly unique IP address and a partly unique browser user agent give
us way more combinations, and so on, an higher level of uniqueness.</p>

<p>So far, so good. I assigned a unique id to a specific user. However, I need
the root url, in order to identify the page that has been originally requested.
This can be easily done, as a resource request of the browser - in this case for
an image tag - adds a <code class="language-plaintext highlighter-rouge">Referer</code> HTTP header, which contains the url of the page
that has been originally visited. As I have only a single domain, I can reduce
this url to the path only, instead of the full url. I do not care about the
query a user can choose, as this will allow him to generate an infinite amount
of page views and unique request ids. Each request id belongs to one specific
path and one specific user.</p>

<p>Adding the path to the hash allows the user to be even more anonymous, as the
server can only identify whether he has called the same url twice (matching
request ids) or not. Without the request hash, tracking across the paths is
possible and the privacy shrinks.</p>

<p>The solution to the last step, hiding the actual information behind the unique
data, is hashing it. The id is then only reversible by brute-forcing every
possible input, which would be useless at this point, as the IP address it not
stored in full length in the unique data and who cares about the user agent.</p>

<p>Summarized, our request id will be a hash of a partially IP address, the
user agent and the path that has been originally requested.</p>

<h3 id="code">Code</h3>

<p>The solution is now defined. A possible implementation can be found below
written in Ruby. Please note, that the provided solution is not production ready
and has no persistent storage. If this kind of concept should be moved to
production, it is suggested to add a database server, taking care of the unique
request ids. However, a cuckoo filter - or other filters - as this will filter
out same requests in order to lower the database server usage.</p>

<p>If this functionality will be abused by other websites, the code will
automatically reject those requests by checking the domain of the <code class="language-plaintext highlighter-rouge">Referer</code>
header.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'sinatra'</span>
<span class="nb">require</span> <span class="s1">'cuckoo_filter'</span>

<span class="nb">require</span> <span class="s1">'uri'</span>
<span class="nb">require</span> <span class="s1">'digest'</span>

<span class="n">set</span> <span class="ss">:port</span><span class="p">,</span> <span class="mi">3001</span>

<span class="c1"># In order to identify unique requests</span>
<span class="n">filter</span> <span class="o">=</span> <span class="no">CuckooFilter</span><span class="p">.</span><span class="nf">make</span><span class="p">(</span><span class="ss">size: </span><span class="mi">10_000</span><span class="p">)</span>
<span class="c1"># Final statistics</span>
<span class="n">counts</span> <span class="o">=</span> <span class="no">Hash</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="n">get</span> <span class="s1">'/image.jpg'</span> <span class="k">do</span>
  <span class="n">content_type</span> <span class="s1">'image/jpg'</span>
  <span class="c1"># Referer must be given</span>
  <span class="k">return</span> <span class="k">if</span> <span class="n">request</span><span class="p">.</span><span class="nf">referer</span><span class="p">.</span><span class="nf">nil?</span>
  <span class="n">url</span> <span class="o">=</span> <span class="no">URI</span><span class="p">(</span><span class="n">request</span><span class="p">.</span><span class="nf">referer</span><span class="p">)</span>
  <span class="c1"># Root referer host is required</span>
  <span class="k">return</span> <span class="k">unless</span> <span class="n">url</span><span class="p">.</span><span class="nf">host</span> <span class="o">==</span> <span class="s1">'fcused.at'</span>
  <span class="c1"># Remove last ip address block</span>
  <span class="n">ip</span> <span class="o">=</span> <span class="n">request</span><span class="p">.</span><span class="nf">ip</span><span class="p">[</span><span class="mi">0</span><span class="o">...</span><span class="n">request</span><span class="p">.</span><span class="nf">ip</span><span class="p">.</span><span class="nf">rindex</span><span class="p">(</span><span class="s1">'.'</span><span class="p">)]</span>
  <span class="c1"># Convert meta-data into non-meta-data identifier</span>
  <span class="nb">hash</span> <span class="o">=</span> <span class="no">Digest</span><span class="o">::</span><span class="no">SHA256</span><span class="p">.</span><span class="nf">hexdigest</span> <span class="s2">"</span><span class="si">#{</span><span class="n">ip</span><span class="si">}#{</span><span class="n">request</span><span class="p">.</span><span class="nf">user_agent</span><span class="si">}#{</span><span class="n">url</span><span class="p">.</span><span class="nf">path</span><span class="si">}</span><span class="s2">"</span>
  <span class="c1"># Check if request already exists</span>
  <span class="k">unless</span> <span class="n">filter</span><span class="p">.</span><span class="nf">lookup</span> <span class="nb">hash</span>
    <span class="c1"># Add request if to filter</span>
    <span class="n">filter</span><span class="p">.</span><span class="nf">insert</span> <span class="nb">hash</span>
    <span class="c1"># Increment counts</span>
    <span class="n">counts</span><span class="p">[</span><span class="n">url</span><span class="p">.</span><span class="nf">path</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">get</span> <span class="s1">'/stats'</span> <span class="k">do</span>
  <span class="c1"># Return the current statistics</span>
  <span class="n">counts</span>
<span class="k">end</span>
</code></pre></div></div>

<p>In order to count specific requests on some pages, the following HTML need to be
added.</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;img</span> <span class="na">src=</span><span class="s">"http://localhost:3001/image.jpg"</span> <span class="na">style=</span><span class="s">"display: none;"</span><span class="nt">&gt;</span>
</code></pre></div></div>

<p>This kind of implementation can be applied to any content type. The request
since can be reduced to under 100bytes, meaning there is no time and bandwidth
consumed in web analytics. An example implementation in golang can be found here
<a href="https://github.com/oltdaniel/door">https://github.com/oltdaniel/door</a>.</p>

<h3 id="conclusion">Conclusion</h3>

<p>As an final statement I can say, that the statistics I collect from the
requests and store in our database, deliver enough information to elaborate
facts I can reuse for marketing purposes. Besides, I can say, due to the low
amount of information, I will have a low bandwidth usage and deliver a
minimalistic solution. The privacy aspect I described in the beginning is
simply covered by the hashing of the user id and removing the last block of the
IP address.</p>

<!-- References -->
<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>IP Anonymization in Analytics by Google <a href="https://support.google.com/analytics/answer/2763052">https://support.google.com/analytics/answer/2763052</a> <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

</article>
</main>

<footer>
    <p>Copyright &copy; 2023 Daniel Oltmanns.</p>
    <p>All Rights Reserved.</p>
</footer>
</body>
</html>