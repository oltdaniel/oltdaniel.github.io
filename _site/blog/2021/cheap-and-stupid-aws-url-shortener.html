<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>Cheap and stupid AWS URL shortener</title>

    <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Cheap and stupid AWS URL shortener | Daniel Oltmanns</title>
<meta name="generator" content="Jekyll v4.3.2" />
<meta property="og:title" content="Cheap and stupid AWS URL shortener" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="How cheap and low-tech can we make an URL shortener?" />
<meta property="og:description" content="How cheap and low-tech can we make an URL shortener?" />
<link rel="canonical" href="http://localhost:4000/blog/2021/cheap-and-stupid-aws-url-shortener.html" />
<meta property="og:url" content="http://localhost:4000/blog/2021/cheap-and-stupid-aws-url-shortener.html" />
<meta property="og:site_name" content="Daniel Oltmanns" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-12-13T00:00:00+01:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Cheap and stupid AWS URL shortener" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2021-12-13T00:00:00+01:00","datePublished":"2021-12-13T00:00:00+01:00","description":"How cheap and low-tech can we make an URL shortener?","headline":"Cheap and stupid AWS URL shortener","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/blog/2021/cheap-and-stupid-aws-url-shortener.html"},"url":"http://localhost:4000/blog/2021/cheap-and-stupid-aws-url-shortener.html"}</script>
<!-- End Jekyll SEO tag -->


    <link media="all" rel="stylesheet" href="/assets/fonts/inter.css">
    <link media="all" rel="stylesheet" href="/assets/style.css">
</head>
<body>
    <header>
    <h1>Daniel Oltmanns</h1>

    
    <p>personal blog and collection of tips</p>
    

    <nav>
        
        <a href="/" >About</a>
        
        <a href="/blog" >Blog</a>
        
        <a href="/tips" >Tips</a>
        
    </nav>
</header>

<main>
<article>
    <h2>Cheap and stupid AWS URL shortener</h2>
    <time>2021-12-13</time>

    <p>AWS is known to be not the cheapest option when it comes to cloud services. But the options it will give you, are endless due to its massive product selection.So the challenge is, <em>how low-tech or stupid and especially how cheap can you make an URL shortener?</em></p>

<blockquote>
  <p><strong>NOTE</strong>: There are some drawbacks that we were willing to accept during the impelemntation of this functionality.</p>
  <ol>
    <li>Redirects will only work in browsers.</li>
    <li>No quick changes to registered shortned urls.</li>
    <li>No interface to register new urls.</li>
  </ol>

  <p>Keep this in mind.</p>
</blockquote>

<h2 id="first-approach">First approach</h2>

<p>As I was challenged with this project in the end of 2020, where I was new to AWS, so my first approach was a bit naive. Before I focused on creating custom REST APIs running on their own servers and containers. Therefore, I decided to checkout the massive AWS product page.<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup></p>

<p>Quickly I relaized, hosting containers or allocating custom a server isn’t easy nor cheap. Especially hosting containers has dozens of options, as pointed out by Corey Quinn in his article “The 17 Ways to Run Containers on AWS”.<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup> So this is not the way to go.</p>

<h2 id="rethinking">Rethinking</h2>

<p>Let us just throw everythong over board and start with an empty sheet of paper and focus on the different parts our URL shortener exists of.</p>

<blockquote>
  <ol>
    <li>Accepting requests and responding to them.</li>
    <li>A central entity which looks up the requested url for an redirection target.</li>
    <li>Something that will actually redirect the request.</li>
  </ol>
</blockquote>

<h3 id="how-to-redirect">How to redirect?</h3>

<p>We have multiple options for how to redirect a HTTP request. We could either respond with an HTTP <code class="language-plaintext highlighter-rouge">Location</code> header or serve some HTML which would redirect the browser to the actual URL.</p>

<p>Responding with an custom HTTP header would mean, we need to execute some code every time a request comes in. That isn’t stupid or cheap enough. <em>So how could we include a redirection in the HTML file?</em></p>

<p>There are two simple options.</p>

<h5 id="option-1-javascript">Option 1: JavaScript</h5>
<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;html&gt;</span>
    <span class="nt">&lt;head&gt;</span>
        <span class="nt">&lt;title&gt;</span>Redirecting...<span class="nt">&lt;/title&gt;</span>
    <span class="nt">&lt;/head&gt;</span>
    <span class="nt">&lt;script&gt;</span>
        <span class="nb">window</span><span class="p">.</span><span class="nx">location</span><span class="p">.</span><span class="nx">href</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">URL</span><span class="dl">'</span><span class="p">;</span>
    <span class="nt">&lt;/script&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div></div>

<h5 id="option-2-meta-tag">Option 2: Meta Tag</h5>
<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;html&gt;</span>
    <span class="nt">&lt;head&gt;</span>
        <span class="nt">&lt;title&gt;</span>Redirecting...<span class="nt">&lt;/title&gt;</span>
        <span class="nt">&lt;meta</span> <span class="na">http-equiv=</span><span class="s">"refresh"</span> <span class="na">content=</span><span class="s">"0; url=URL"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;/head&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div></div>

<p>Stupid and cheap being our main goal here, <a href="#option-2-meta-tag">Option 2</a> is our way to go. We don’t require some script executions and the browser needs to parse the HTML elements anyway.</p>

<p>Summarized, we only need to serve the correct HTML file, which is the easiest thing to deploy and manage. The actual services we will use will be introduced later.</p>

<h3 id="how-to-map-request-to-target-url">How to map request to target URL?</h3>

<p>We have now resolved the question on how to redirect, but we also need to decide on how we map a requested URL to the specific HTML file. The most simple approach we could use is, encoding the whole requested URL into a filename. This will deliver is an 1:1 mapping of requested url to filename.</p>

<p><em>Which encoding?</em> The encoding everybody uses to encode anything on the web into a safe string. <strong>Base64</strong>. This means, we can map our requests like this:</p>

<table>
  <thead>
    <tr>
      <th>Requested URL</th>
      <th>Filename</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">example.org/abc123/welt</code></td>
      <td><code class="language-plaintext highlighter-rouge">ZXhhbXBsZS5vcmcvYWJjMTIzL3dlbHQK.html</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">something.example.org</code></td>
      <td><code class="language-plaintext highlighter-rouge">c29tZXRoaW5nLmV4YW1wbGUub3JnCg==.html</code></td>
    </tr>
  </tbody>
</table>

<h3 id="handling-traffic">Handling traffic</h3>

<p>As mentioned in <a href="#how-to-redirect">How to redirect?</a> we just need to serve the correct HTML file. <em>But where will the files be stored</em>, <em>how do we serve these files</em> and <em>where will be map the request to the filename?</em> So lets dive right into one way, on how to serve static files via AWS.</p>

<h4 id="storing-the-html-files">Storing the HTML files</h4>

<p>Storing files is very easy to answer even without the AWS Product Page. Amazon S3.<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup> We have a lot of flexibility on how the access is managed and how files will stored/moved and much more.</p>

<h4 id="serving-the-html-files">Serving the HTML files</h4>

<p>Serving static files is made easy thanks to AWS Cloudfront.<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">4</a></sup> We can quickly setup custom Domains, SSL certificates and serve files out of S3 buckets.</p>

<h4 id="mapping-request-to-filename">Mapping request to filename</h4>

<p>The connection between an AWS Cloudfront instance and an S3 buckets consists of 4 different event types.</p>

<ul>
  <li><strong>Viewer request</strong>: The request that describes the incoming traffic to cloudfront directly.</li>
  <li><strong>Viewer response</strong>: The response right before it will be sent to the client.</li>
  <li><strong>Origin request</strong>: The request behind Cloudfront to its origin, if there is a cache miss.</li>
  <li><strong>Origin response</strong>: The response of the origin, before it is handled by Cloudfront.</li>
</ul>

<p>The event interesting to us is the <strong>Origin request</strong> event. At this stage Cloudfront doesn’t know what to serve and requires a new mapping of the request to an target filename in our S3 bucket.</p>

<h2 id="implementation">Implementation</h2>

<p><img src="/assets/posts/cheap-and-stupid-aws-urlshortener/infrastructure.svg" alt="" /></p>

<blockquote>
  <p><strong>NOTE</strong>: This post intends to show what is possible with AWS Lambda and Cloudfront. If any information is outdated or actions you do based on this post cause any harm (finacially or in any other way) I’m not responsible.</p>
</blockquote>

<h3 id="s3-bucket">S3 Bucket</h3>

<p><img src="/assets/posts/cheap-and-stupid-aws-urlshortener/create_s3_bucket.png" alt="" /></p>

<p>We don’t need to change anything else in the default options of the bucket settings. Just pick a name an region that suits you.</p>

<h3 id="lambdaedge">Lambda@Edge</h3>

<p>Our mapping from the request to the specific base64 filename will be done with a Lambda function. To be exact an Lambda@Edge function. This difference is very important, as Cloudfront in the next section, will only allow Lambda@Edge functions due to the deployment region.</p>

<p>For this, change you AWS region to <code class="language-plaintext highlighter-rouge">us-east-1</code>, the global AWS region. Here you will open Lambda and create a new Lambda function that will accept our cloudfront requests.</p>

<p><img src="/assets/posts/cheap-and-stupid-aws-urlshortener/create_lambda_function_1.png" alt="" /></p>

<p>Now jump into the Lambda editor and use the following code and click Deploy!</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>

<span class="c1">// Some helper functions from StackOverflow</span>
<span class="kd">const</span> <span class="nx">pointsToFile</span> <span class="o">=</span> <span class="nx">uri</span> <span class="o">=&gt;</span> <span class="sr">/</span><span class="se">\/[^/]</span><span class="sr">+</span><span class="se">\.[^/]</span><span class="sr">+$/</span><span class="p">.</span><span class="nf">test</span><span class="p">(</span><span class="nx">uri</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">hasTrailingSlash</span> <span class="o">=</span> <span class="nx">uri</span> <span class="o">=&gt;</span> <span class="nx">uri</span><span class="p">.</span><span class="nf">endsWith</span><span class="p">(</span><span class="dl">'</span><span class="s1">/</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">needsTrailingSlash</span> <span class="o">=</span> <span class="nx">uri</span> <span class="o">=&gt;</span> <span class="o">!</span><span class="nf">pointsToFile</span><span class="p">(</span><span class="nx">uri</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nf">hasTrailingSlash</span><span class="p">(</span><span class="nx">uri</span><span class="p">);</span>

<span class="nx">exports</span><span class="p">.</span><span class="nx">handler</span> <span class="o">=</span> <span class="p">(</span><span class="nx">event</span><span class="p">,</span> <span class="nx">context</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="c1">// Extract the request from the CloudFront event that is sent to Lambda@Edge </span>
    <span class="kd">let</span> <span class="nx">request</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">Records</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">cf</span><span class="p">.</span><span class="nx">request</span><span class="p">;</span>

    <span class="k">try</span> <span class="p">{</span>
        <span class="c1">// Extract the URI and query string from the request</span>
        <span class="kd">const</span> <span class="nx">hostname</span> <span class="o">=</span> <span class="nx">request</span><span class="p">.</span><span class="nx">headers</span><span class="p">.</span><span class="nx">host</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">value</span><span class="p">;</span>
        <span class="kd">let</span> <span class="nx">uri</span> <span class="o">=</span> <span class="nx">request</span><span class="p">.</span><span class="nx">uri</span><span class="p">;</span>

        <span class="c1">// Extend trailing slash if not present</span>
        <span class="k">if </span><span class="p">(</span><span class="nf">needsTrailingSlash</span><span class="p">(</span><span class="nx">uri</span><span class="p">))</span> <span class="p">{</span>
            <span class="nx">uri</span> <span class="o">+=</span> <span class="dl">'</span><span class="s1">/</span><span class="dl">'</span>
        <span class="p">}</span>

        <span class="c1">// Base64 encode</span>
        <span class="kd">const</span> <span class="nx">newUri</span> <span class="o">=</span> <span class="nx">Buffer</span><span class="p">.</span><span class="k">from</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="nx">hostname</span><span class="p">}${</span><span class="nx">uri</span><span class="p">}</span><span class="s2">`</span><span class="p">).</span><span class="nf">toString</span><span class="p">(</span><span class="dl">'</span><span class="s1">base64</span><span class="dl">'</span><span class="p">);</span>

        <span class="c1">// Assign new uri</span>
        <span class="nx">request</span><span class="p">.</span><span class="nx">uri</span> <span class="o">=</span> <span class="s2">`/</span><span class="p">${</span><span class="nx">newUri</span><span class="p">}</span><span class="s2">.html`</span><span class="p">;</span>

        <span class="c1">// Change host header to origin header, else S3 fails</span>
        <span class="nx">request</span><span class="p">.</span><span class="nx">headers</span><span class="p">.</span><span class="nx">host</span> <span class="o">=</span> <span class="p">[{</span><span class="dl">"</span><span class="s2">key</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Host</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">value</span><span class="dl">"</span><span class="p">:</span> <span class="nx">request</span><span class="p">.</span><span class="nx">origin</span><span class="p">.</span><span class="nx">s3</span><span class="p">.</span><span class="nx">domainName</span><span class="p">}]</span>
    <span class="p">}</span> <span class="k">catch </span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nf">error</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// Return to CloudFront</span>
    <span class="k">return</span> <span class="nf">callback</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">request</span><span class="p">);</span>

<span class="p">};</span>
</code></pre></div></div>

<p>With this done, we can prepare our Cloudfront Distribution,</p>

<h3 id="cloudfront">Cloudfront</h3>

<h4 id="cache-policy">Cache Policy</h4>

<p>As Cloudfront caches as much as it can, we need to tweak the default policy to support the correct handling of subdomains. For that, jump into the side menu and open “Policies” and create a new policy.</p>

<p>Just give it a good name and add the <code class="language-plaintext highlighter-rouge">Host</code> header to the “Cache key settings”.</p>

<p><img src="/assets/posts/cheap-and-stupid-aws-urlshortener/create_cloudfront_policy.png" alt="" /></p>

<blockquote>
  <p><strong>Explanation</strong>: If we don’t add the host header to the caching policy, only the main domain will be used for the cache. Which means, if <code class="language-plaintext highlighter-rouge">example.org/hallo</code> is called first, <code class="language-plaintext highlighter-rouge">sub.example.org/hallo</code> will be resolved to the same cached content.</p>

  <p><em>Don’t ask, how I learned that…</em></p>
</blockquote>

<h4 id="distribution">Distribution</h4>

<p><img src="/assets/posts/cheap-and-stupid-aws-urlshortener/create_cloudfront_distribution_1.png" alt="" /></p>

<p>As the origin domain, select the S3 Bcuket you’ve just created. As we made it a private bucket with strict policies (the default options), we need to allow Cloudfront access to that specific S3 bucket. For that, we can simply choose “Yes use OAI” and use “Create new OAI” to automatically create the required access rights. <strong>Don’t forget</strong> to choose “Yes, update the bucket policy”, else the policiy exists but hasn’t been registered within that bucket.</p>

<p><img src="/assets/posts/cheap-and-stupid-aws-urlshortener/create_cloudfront_distribution_2.png" alt="" />
In order to make caching work correctly, we select our previously created custom Caching Policy. Additionally, we <strong>require</strong> to known the host that is called to resolve the full request url including the full domain. For that we simply use the “AllViewer” policy.</p>

<p><img src="/assets/posts/cheap-and-stupid-aws-urlshortener/create_cloudfront_distribution_3.png" alt="" />
Now the only main thing left for the shortener is, to select our Lambda function we have created before. The “Function ARN/Name” can be found in the Lambda function details and just needs to be copied.</p>

<p>Additionally, I recommend to select “Redirect HTTP to HTTPS” add your own custom CNAME and Custom SSL certificate in combination with Route53.<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">5</a></sup> Moreover, using “Error pages” in the Cloudfront Distibution settings is recommended. Simply redirect <code class="language-plaintext highlighter-rouge">403</code> and <code class="language-plaintext highlighter-rouge">404</code> to <code class="language-plaintext highlighter-rouge">/</code> which will than resolve via the Lambda function to the base64 code of your root domain.</p>

<p>Now you can click <strong>Create distribution</strong>.</p>

<h2 id="workflow-for-new-urls">Workflow for new urls</h2>

<p>As we didn’t require any interface for registering any new urls, we can simply create a new HTML file with a bash script and upload it to the bucket with the AWS cli. In the real world, something like an Slack Bot or similar that uses an Lambda function would a good way to register new URLs with an random id, like <code class="language-plaintext highlighter-rouge">example.org/abc123</code>.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/usr/bin/env bash</span>

<span class="nv">SOURCE</span><span class="o">=</span><span class="nv">$1</span>
<span class="nv">TARGET</span><span class="o">=</span><span class="nv">$2</span>

<span class="nv">HTML</span><span class="o">=</span><span class="s2">"&lt;html&gt;
    &lt;head&gt;
        &lt;meta http-equiv=</span><span class="se">\"</span><span class="s2">refresh</span><span class="se">\"</span><span class="s2"> content=</span><span class="se">\"</span><span class="s2">0; url=</span><span class="nv">$TARGET</span><span class="se">\"</span><span class="s2"> /&gt;
    &lt;/head&gt;
&lt;/html&gt;"</span>

<span class="nv">HASH</span><span class="o">=</span><span class="si">$(</span><span class="nb">echo</span> <span class="nt">-ne</span> <span class="s2">"</span><span class="nv">$SOURCE</span><span class="s2">"</span> | <span class="nb">base64</span><span class="si">)</span>
<span class="nv">FILEPATH</span><span class="o">=</span><span class="s2">"</span><span class="si">$(</span><span class="nb">dirname</span> <span class="nv">$0</span><span class="si">)</span><span class="s2">/</span><span class="k">${</span><span class="nv">HASH</span><span class="k">}</span><span class="s2">.html"</span>

<span class="nb">echo</span> <span class="s2">"</span><span class="nv">$HTML</span><span class="s2">"</span> <span class="o">&gt;</span> <span class="nv">$FILEPATH</span>
aws s3 <span class="nb">cp</span> <span class="nv">$FILEPATH</span> s3://urlshortener/
</code></pre></div></div>

<p>If you want to replace an existing shortned URL, you also need to invalidate the Cloudfront cache before the change takes effect.<sup id="fnref:6" role="doc-noteref"><a href="#fn:6" class="footnote" rel="footnote">6</a></sup></p>

<h2 id="costs">Costs</h2>

<p>Lets assume some traffic stuff. Every registered URL is requested 10000 times a month and we have 1000 registered URLs. Additionally, we <strong>exclude the free tier</strong> for full price transparency.</p>

<blockquote>
  <p>Pricing data from <code class="language-plaintext highlighter-rouge">2021-12-13</code>.</p>
</blockquote>

<h4 id="costs-lambdaedge">Costs Lambda@Edge</h4>

<p>Our Lambda function takes <code class="language-plaintext highlighter-rouge">2ms</code> to respond if hot. But let us assume the worst case with <code class="language-plaintext highlighter-rouge">100ms</code> on average. We only require the minimum RAM requirement <code class="language-plaintext highlighter-rouge">128MB</code>.</p>

<p>Which means using the AWS calculator<sup id="fnref:7" role="doc-noteref"><a href="#fn:7" class="footnote" rel="footnote">7</a></sup>:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1,000 requests x 100 ms x 0.001 ms to sec conversion factor = 100.00 total compute (seconds)
0.125 GB x 100.00 seconds = 12.50 total compute (GB-s)
12.50 GB-s x 0.00005001 USD = 0.00 USD (monthly compute charges)
1,000 requests x 0.0000006 USD = 0.00 USD (monthly request charges)
Lambda@Edge costs (monthly): 0.0006 USD
</code></pre></div></div>

<h4 id="costs-s3">Costs S3</h4>

<p>Our HTML template file without the target URL itself consumes <code class="language-plaintext highlighter-rouge">98bytes</code>. An Google Drive target URL requires about <code class="language-plaintext highlighter-rouge">103bytes</code>. So we have <code class="language-plaintext highlighter-rouge">1000 URLs * (98bytes + 103bytes) = 196000 bytes = 196kB</code>. Additionally we have 1000 PUT, COPY, POST, LIST  requests and 1000 GET, SELECT requests and return the stored storage once thanks to the caching of cloudfront.</p>

<p>Which means using the AWS calculator<sup id="fnref:7:1" role="doc-noteref"><a href="#fn:7" class="footnote" rel="footnote">7</a></sup>:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Tiered price for: 0.000196 GB
0.000196 GB x 0.0230000000 USD = 0.00 USD
Total tier cost = 0.0000 USD (S3 Standard storage cost)
1,000 PUT requests for S3 Storage x 0.000005 USD per request = 0.005 USD (S3 Standard PUT requests cost)
1,000 GET requests in a month x 0.0000004 USD per request = 0.0004 USD (S3 Standard GET requests cost)
0.000196 GB x 0.0007 USD = 0.00 USD (S3 select returned cost)
0.0004 USD + 0.005 USD = 0.01 USD (Total S3 Standard Storage, data requests, S3 select cost)
S3 Standard cost (monthly): 0.01 USD
</code></pre></div></div>

<h4 id="costs-cloudfront">Costs Cloudfront</h4>

<p>Assuming we only send traffic to Europe, all saved URls will be called 10000times, which means we serve <code class="language-plaintext highlighter-rouge">195kB * 10000requests = 1.96GB</code> of data with a total of 10000000 requests.</p>

<p>Which means using the AWS calculator<sup id="fnref:7:2" role="doc-noteref"><a href="#fn:7" class="footnote" rel="footnote">7</a></sup>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Tiered price for: 1.96 GB
1.96 GB x 0.0850000000 USD = 0.17 USD
Total tier cost = 0.17 USD (Data transfer out to internet from Europe)
Data transfer out to internet cost: 0.17 USD
Data transfer out to origin cost: 0 USD
10,000,000 requests x 0.0000012 USD = 12.00 USD (HTTPS requests from Europe)
Requests cost: 12.00 USD
0.17 USD + 12.00 USD = 12.17 USD (Total cost Europe)
CloudFront price Europe (monthly): 12.17 USD
</code></pre></div></div>

<h4 id="costs-summary">Costs summary</h4>

<p>Which means, we have a monthly total of <code class="language-plaintext highlighter-rouge">12.18USD</code> <strong>if we don’t use the free tier</strong>. If we do, we pay nothing as Cloudfront has a huge Free tier since <code class="language-plaintext highlighter-rouge">2021-12-01</code> with 1TB free traffic and 10million free requests. Our S3 usage is so low, it is covered by the free tier anyway and the Lambda@Edge costs are somewhere in the less than 1cent region.</p>

<h2 id="summary">Summary</h2>

<p><em>Should you do this?</em> … <strong>Definitely not.</strong> Search for an existing service that also includes an fancy web interface and don’t waste hours trying to make something fit, it wasn’t designed for. But this is a great way of learning how you can combine Lambda@Edge with Cloudfront to create something new.</p>

<!-- Footnotes -->
<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>AWS products page: <a href="https://aws.amazon.com/products">https://aws.amazon.com/products</a> <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>“The 17 Ways to Run Containers on AWS” by Corey Quinn at LastWeekInAWS: <a href="https://www.lastweekinaws.com/blog/the-17-ways-to-run-containers-on-aws/">https://www.lastweekinaws.com/blog/the-17-ways-to-run-containers-on-aws</a> <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>Amazon S3 Product Page: <a href="https://aws.amazon.com/s3">https://aws.amazon.com/s3</a> <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>Amazon Cloudfront Product Page: <a href="https://aws.amazon.com/cloudfront">https://aws.amazon.com/cloudfront</a> <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p>AWS Documentation “Using custom URLs by adding alternate domain names (CNAMEs)”: <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/CNAMEs.html">https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/CNAMEs.html</a> <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:6" role="doc-endnote">
      <p>AWS Documentation: “Invalidating Files”: <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Invalidation.html">https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Invalidation.html</a> <a href="#fnref:6" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:7" role="doc-endnote">
      <p>AWS Calculator: <a href="https://calculator.aws/">https://calculator.aws</a> <a href="#fnref:7" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:7:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a> <a href="#fnref:7:2" class="reversefootnote" role="doc-backlink">&#8617;<sup>3</sup></a></p>
    </li>
  </ol>
</div>

</article>
</main>

<footer>
    <p>Copyright &copy; 2023 Daniel Oltmanns.</p>
    <p>All Rights Reserved.</p>
</footer>
</body>
</html>