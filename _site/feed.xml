<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://oltdaniel.eu/feed.xml" rel="self" type="application/atom+xml" /><link href="https://oltdaniel.eu/" rel="alternate" type="text/html" /><updated>2023-08-12T17:42:53+02:00</updated><id>https://oltdaniel.eu/feed.xml</id><title type="html">Daniel Oltmanns</title><entry><title type="html">Minimal Golang Docker image</title><link href="https://oltdaniel.eu/blog/2022/minimal-golang-docker-image.html" rel="alternate" type="text/html" title="Minimal Golang Docker image" /><published>2022-01-04T00:00:00+01:00</published><updated>2022-01-04T00:00:00+01:00</updated><id>https://oltdaniel.eu/blog/2022/minimal-golang-docker-image</id><content type="html" xml:base="https://oltdaniel.eu/blog/2022/minimal-golang-docker-image.html"><![CDATA[<p>As golang is a compiled programming language, we don’t need to store all the unecessary build environments in our final image. So lets see, if we get rid of everything, what we need to importat again to not break anything.</p>

<p>In order to solve everything in a single <code class="language-plaintext highlighter-rouge">Dockerfile</code>, we will use multi-stage builds. <sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup> Our first stage will be focused on the actual compiling of our application. In order to cover as many features on our application as possible, I’ll create an API that uses timezone information, calls an external service via https and uses the lua shared library.</p>

<h2 id="project-setup">Project setup</h2>

<p>First we create a new folder and initialize our dependecy manager and load some dependencies.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>go mod init github.com/oltdaniel/golang-minimal-docker
<span class="c"># we will use gin as our webserver</span>
go get github.com/gin-gonic/gin
<span class="c"># and a lua binding</span>
go get github.com/aarzilli/golua/lua
</code></pre></div></div>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"io"</span>
	<span class="s">"log"</span>
	<span class="s">"net/http"</span>
	<span class="s">"time"</span>

	<span class="s">"github.com/aarzilli/golua/lua"</span>
	<span class="s">"github.com/gin-gonic/gin"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">s</span> <span class="o">:=</span> <span class="n">gin</span><span class="o">.</span><span class="n">Default</span><span class="p">()</span>

	<span class="c">// call another api via https</span>
	<span class="c">// this will require ca-certificates</span>
	<span class="c">// for veriying the ssl certificate</span>
	<span class="n">s</span><span class="o">.</span><span class="n">GET</span><span class="p">(</span><span class="s">"/ip"</span><span class="p">,</span> <span class="k">func</span><span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">gin</span><span class="o">.</span><span class="n">Context</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">resp</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">http</span><span class="o">.</span><span class="n">Get</span><span class="p">(</span><span class="s">"https://api.ipify.org"</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
			<span class="n">log</span><span class="o">.</span><span class="n">Fatal</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="n">c</span><span class="o">.</span><span class="n">Status</span><span class="p">(</span><span class="n">resp</span><span class="o">.</span><span class="n">StatusCode</span><span class="p">)</span>
		<span class="n">io</span><span class="o">.</span><span class="n">Copy</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">Writer</span><span class="p">,</span> <span class="n">resp</span><span class="o">.</span><span class="n">Body</span><span class="p">)</span>
	<span class="p">})</span>

	<span class="c">// convert some stuff within the timezones</span>
	<span class="c">// this will require the timezone data</span>
	<span class="n">s</span><span class="o">.</span><span class="n">GET</span><span class="p">(</span><span class="s">"/time"</span><span class="p">,</span> <span class="k">func</span><span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">gin</span><span class="o">.</span><span class="n">Context</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">wantedTimeLocation</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">time</span><span class="o">.</span><span class="n">LoadLocation</span><span class="p">(</span><span class="s">"Asia/Tokyo"</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
			<span class="n">log</span><span class="o">.</span><span class="n">Fatal</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="n">c</span><span class="o">.</span><span class="n">String</span><span class="p">(</span>
      <span class="m">200</span><span class="p">,</span>
      <span class="s">"server time in japan would be %v"</span><span class="p">,</span>
      <span class="n">time</span><span class="o">.</span><span class="n">Now</span><span class="p">()</span><span class="o">.</span><span class="n">In</span><span class="p">(</span><span class="n">wantedTimeLocation</span><span class="p">)</span><span class="o">.</span><span class="n">String</span><span class="p">())</span>
	<span class="p">})</span>

	<span class="c">// here we create a lua machine</span>
	<span class="c">// register a custom response function</span>
	<span class="c">// and execute the response directly from within the lua machine</span>
	<span class="c">// this will require the use of the lua library</span>
	<span class="n">s</span><span class="o">.</span><span class="n">GET</span><span class="p">(</span><span class="s">"/lua"</span><span class="p">,</span> <span class="k">func</span><span class="p">(</span><span class="n">c</span> <span class="o">*</span><span class="n">gin</span><span class="o">.</span><span class="n">Context</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lmachine</span> <span class="o">:=</span> <span class="n">lua</span><span class="o">.</span><span class="n">NewState</span><span class="p">()</span>
		<span class="k">defer</span> <span class="n">lmachine</span><span class="o">.</span><span class="n">Close</span><span class="p">()</span>

		<span class="n">lmachine</span><span class="o">.</span><span class="n">Register</span><span class="p">(</span><span class="s">"response"</span><span class="p">,</span> <span class="k">func</span><span class="p">(</span><span class="n">ls</span> <span class="o">*</span><span class="n">lua</span><span class="o">.</span><span class="n">State</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
			<span class="n">resp</span> <span class="o">:=</span> <span class="n">ls</span><span class="o">.</span><span class="n">ToString</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>
			<span class="n">c</span><span class="o">.</span><span class="n">String</span><span class="p">(</span><span class="m">200</span><span class="p">,</span> <span class="n">resp</span><span class="p">)</span>
			<span class="k">return</span> <span class="m">1</span>
		<span class="p">})</span>

		<span class="n">err</span> <span class="o">:=</span> <span class="n">lmachine</span><span class="o">.</span><span class="n">DoString</span><span class="p">(</span><span class="s">"response 'hello world'"</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
			<span class="n">log</span><span class="o">.</span><span class="n">Fatal</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">})</span>

	<span class="n">s</span><span class="o">.</span><span class="n">Run</span><span class="p">(</span><span class="s">":3001"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="first-stage">First stage</h2>

<div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># use a fully featured golang build environment</span>
<span class="k">FROM</span><span class="w"> </span><span class="s">golang:latest</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="s">builder</span>
<span class="c"># install project dependencies</span>
<span class="k">RUN </span>apt update <span class="o">&amp;&amp;</span> apt <span class="nb">install</span> <span class="nt">-y</span> liblua5.1
<span class="c"># select a space for our work</span>
<span class="k">WORKDIR</span><span class="s"> /app</span>
<span class="c"># copy dependency files</span>
<span class="k">COPY</span><span class="s"> go.mod .</span>
<span class="k">COPY</span><span class="s"> go.sum .</span>
<span class="c"># install dependencies</span>
<span class="k">RUN </span>go mod download
<span class="c"># copy everything else</span>
<span class="k">COPY</span><span class="s"> . .</span>
<span class="c"># compile our golang project</span>
<span class="k">RUN </span><span class="nv">GOOS</span><span class="o">=</span>linux go build <span class="nt">-a</span> main.go
<span class="c"># expose e.g. a API port</span>
<span class="k">EXPOSE</span><span class="s"> 3001</span>
<span class="c"># start our application if no exec command given</span>
<span class="k">CMD</span><span class="s"> ["/app/main"]</span>
</code></pre></div></div>
<p>At this point, we don’t really care about the image size at all. We can utilize all tools we require in our build environment due to the default debian system. The order of the build steps are essential at this point, if you want to reduce the number of total steps that need to be execute during a new build of the image.</p>

<ol>
  <li>Install any system wide packages that are required via <code class="language-plaintext highlighter-rouge">apt</code>.</li>
  <li>Specify your work environment and install only the project related dependencies.</li>
  <li>Copy the actual source code of you application.</li>
  <li>Compile everything.</li>
</ol>

<p>It is important to note here, that the use of <code class="language-plaintext highlighter-rouge">.dockerignore</code> will also help to reduce the build steps, as the <code class="language-plaintext highlighter-rouge">COPY . .</code> step will be executed again, if anything in the project folder changed, that is not marked to be ignored in the <code class="language-plaintext highlighter-rouge">.dockerignore</code> file.</p>

<p>The image we have here is a total of <code class="language-plaintext highlighter-rouge">1.19GB</code>.</p>

<h2 id="second-stage">Second stage</h2>

<p>The second stage can be split into to different approaches, which will both result in changes of our first stage. You need to ask yourself now, whether your project has any direct usage of non-go libraries. An example for this can be the use of the shared lua library for some embedded scripting functionalities. In general, if you don’t really known how your libraries work under the hood or just have too many to check them manually, you can simply try to compile them with both approaches and test it. The <code class="language-plaintext highlighter-rouge">scratch</code> image with not dependencies at all will however be smaller.</p>

<h3 id="second-stage-for-system-libraries">Second stage: For system libraries</h3>

<p>Compiling everything into a static library or even into the executable itself can be really difficult and heavily depends on the implementation of dependecy owner. For a better developer experience I would suggest to make use of the <code class="language-plaintext highlighter-rouge">alpine</code> linux image. It is very minimal, but still comes with a huge selection of packages that can be installed. As the Golang docker image also supports and alpine image, I suggest we use that, as especially the libraries we may require, will be exactly the same between the first and second stage, which reduces the number of bugs we may run into, like different package names.</p>

<p>So lets rebuild the first stage and add the second one. In my example I’ll use the <code class="language-plaintext highlighter-rouge">golua</code><sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup> package which requires the shared library of lua.</p>

<div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># first stage for our compiling environment</span>
<span class="k">FROM</span><span class="w"> </span><span class="s">golang:alpine</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="s">builder</span>
<span class="c"># install build tools</span>
<span class="k">RUN </span>apk add <span class="nt">--no-cache</span> build-base
<span class="c"># install libraries</span>
<span class="k">RUN </span>apk add <span class="nt">--no-cache</span> lua5.1-dev
<span class="c"># select a space for our work</span>
<span class="k">WORKDIR</span><span class="s"> /app</span>
<span class="c"># copy dependency files</span>
<span class="k">COPY</span><span class="s"> go.mod .</span>
<span class="k">COPY</span><span class="s"> go.sum .</span>
<span class="c"># install dependencies</span>
<span class="k">RUN </span>go mod download
<span class="c"># copy everything else</span>
<span class="k">COPY</span><span class="s"> . .</span>
<span class="c"># compile our golang project</span>
<span class="k">RUN </span><span class="nv">GOOS</span><span class="o">=</span>linux go build <span class="nt">-a</span> main.go

<span class="c"># second stage that will actually be published/deployed</span>
<span class="k">FROM</span><span class="s"> alpine</span>
<span class="c"># install timezone and certificate files</span>
<span class="k">RUN </span>apk add <span class="nt">--no-cache</span> tzdata ca-certificates
<span class="c"># install libraries</span>
<span class="k">RUN </span>apk add <span class="nt">--no-cache</span> lua5.1-dev
<span class="c"># copy our binary</span>
<span class="k">COPY</span><span class="s"> --from=builder /app/main /</span>
<span class="c"># expose e.g. a API port</span>
<span class="k">EXPOSE</span><span class="s"> 3001</span>
<span class="c"># start our application if no exec command given</span>
<span class="k">CMD</span><span class="s"> ["/main"]</span>
</code></pre></div></div>

<p>This results in an <code class="language-plaintext highlighter-rouge">18MB</code> docker image.</p>

<h3 id="second-stage-just-the-basics">Second stage: Just the basics</h3>

<p>If your project is focused on only in go written depencies and doesn’t cause any problems if you strip away everything from the OS itself.</p>

<blockquote>
  <p>As an example I use the same project, but removed the lua functionality due to the bindings.</p>
</blockquote>

<p>For this, we don’t care about the first stage as we did before. It can be as big as you like, as nothing will be deployed later on and we don’t need to worry about any system libraries. In order to ensure that we don’t run into any issues with out compiled binary, we need to make sure, the go compiler knows that the binary won’t have any access to the current libraries later on. For this we can utilize the compiler flags use in the multistage example of the docker documentation. <sup id="fnref:1:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">CGO_ENABLED=0</code> will tell the go compiler, it doesn’t have access to any system libraries.</li>
  <li>however, the <code class="language-plaintext highlighter-rouge">-installsuffix cgo</code> argument is <strong>not required anymore</strong> as stated in the original GitHub issue about static linking issues. <sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup></li>
</ul>

<div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># use a fully featured golang build environment</span>
<span class="k">FROM</span><span class="w"> </span><span class="s">golang:latest</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="s">builder</span>
<span class="c"># change directory of project</span>
<span class="k">WORKDIR</span><span class="s"> /app</span>
<span class="c"># copy everything else</span>
<span class="k">COPY</span><span class="s"> . .</span>
<span class="c"># compile our golang project</span>
<span class="k">RUN </span><span class="nv">CGO_ENABLED</span><span class="o">=</span>0 <span class="nv">GOOS</span><span class="o">=</span>linux go build <span class="nt">-o</span> main  .

<span class="k">FROM</span><span class="s"> scratch</span>
<span class="c"># copy ca certificates to verify other ssl certificates</span>
<span class="k">COPY</span><span class="s"> --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/ca-certificates.crt</span>
<span class="c"># copy timezone information</span>
<span class="k">COPY</span><span class="s"> --from=builder /usr/share/zoneinfo /usr/share/zoneinfo</span>
<span class="c"># copy actual compiled binary</span>
<span class="k">COPY</span><span class="s"> --from=builder /app/main /</span>
<span class="c"># expose port</span>
<span class="k">EXPOSE</span><span class="s"> 3001</span>
<span class="c"># start binary</span>
<span class="k">CMD</span><span class="s"> ["/main"]</span>
</code></pre></div></div>

<p>This results in an <code class="language-plaintext highlighter-rouge">11.7MB</code> docker image. But we got rid of the shared lua library which was a essential function of our project.</p>

<p>However, there are a lot of projects out there, that port shared library projects to a pure golang version. However, finding bindings for a package you want to you, is way easier. Additionally, many projects like simple APIs don’t actually require any bindings at all, <strong>especially if you require new versions of certain projects</strong>.</p>

<h2 id="result">Result</h2>

<h3 id="full-image-119gb">full image <code class="language-plaintext highlighter-rouge">1.19GB</code></h3>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gd">- extremly large size
- lot of overhead for running this container
</span><span class="gi">+ easy dependency management
+ similar to many developer environments
</span></code></pre></div></div>

<h3 id="alpine-image-18mb">alpine image <code class="language-plaintext highlighter-rouge">18MB</code></h3>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gd">- package names can be different
- more initial work to find all missing dependencies
</span><span class="gi">+ well supported and documented
+ very small image and overhead
</span></code></pre></div></div>

<h3 id="scratch-image-117mb">scratch image <code class="language-plaintext highlighter-rouge">11.7MB</code></h3>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gd">- no usage of complex dependencies
- no system commands (ls, chmod, ...)
</span><span class="gi">+ perfect for small projects
+ runs only what you want
</span></code></pre></div></div>

<h2 id="final-word">Final word</h2>

<p>Again, the choice is up to you. Every option I listed has nearly equal pros and cons and what speaks most to you or to your project can be different. I personally always suggest to take a look at alpine images and maybe your project can be up and running in a much smaller image with just a few lines of changes.</p>

<p>However, even though scratch images look like a nice thing, it breaks things more often than it actually improves it. So I only suggest this type of image, if you really just have a minimal static binary that needs to be honest and doesn’t have any complex dependencies into the system libraries.</p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>docker docs “multistage build”: <a href="https://docs.docker.com/develop/develop-images/multistage-build/"><code class="language-plaintext highlighter-rouge">docs.docker.com/develop/develop-images/multistage-build</code></a> <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:1:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>GitHub <code class="language-plaintext highlighter-rouge">golua</code>: <a href="https://github.com/aarzilli/golua"><code class="language-plaintext highlighter-rouge">github.com/aarzilli/golua</code></a> <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>GitHub comment about newer golang versions and static linking: <a href="https://github.com/golang/go/issues/9344#issuecomment-69944514"><code class="language-plaintext highlighter-rouge">github.com/golang/go/issues/9344#issuecomment-69944514</code></a> <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="golang" /><category term="docker" /><summary type="html"><![CDATA[As golang is a compiled programming language, we don’t need to store all the unecessary build environments in our final image. So lets see, if we get rid of everything, what we need to importat again to not break anything.]]></summary></entry><entry><title type="html">Cheap and stupid AWS URL shortener</title><link href="https://oltdaniel.eu/blog/2021/cheap-and-stupid-aws-url-shortener.html" rel="alternate" type="text/html" title="Cheap and stupid AWS URL shortener" /><published>2021-12-13T00:00:00+01:00</published><updated>2021-12-13T00:00:00+01:00</updated><id>https://oltdaniel.eu/blog/2021/cheap-and-stupid-aws-url-shortener</id><content type="html" xml:base="https://oltdaniel.eu/blog/2021/cheap-and-stupid-aws-url-shortener.html"><![CDATA[<p>AWS is known to be not the cheapest option when it comes to cloud services. But the options it will give you, are endless due to its massive product selection.So the challenge is, <em>how low-tech or stupid and especially how cheap can you make an URL shortener?</em></p>

<blockquote>
  <p><strong>NOTE</strong>: There are some drawbacks that we were willing to accept during the impelemntation of this functionality.</p>
  <ol>
    <li>Redirects will only work in browsers.</li>
    <li>No quick changes to registered shortned urls.</li>
    <li>No interface to register new urls.</li>
  </ol>

  <p>Keep this in mind.</p>
</blockquote>

<h2 id="first-approach">First approach</h2>

<p>As I was challenged with this project in the end of 2020, where I was new to AWS, so my first approach was a bit naive. Before I focused on creating custom REST APIs running on their own servers and containers. Therefore, I decided to checkout the massive AWS product page.<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup></p>

<p>Quickly I relaized, hosting containers or allocating custom a server isn’t easy nor cheap. Especially hosting containers has dozens of options, as pointed out by Corey Quinn in his article “The 17 Ways to Run Containers on AWS”.<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup> So this is not the way to go.</p>

<h2 id="rethinking">Rethinking</h2>

<p>Let us just throw everythong over board and start with an empty sheet of paper and focus on the different parts our URL shortener exists of.</p>

<blockquote>
  <ol>
    <li>Accepting requests and responding to them.</li>
    <li>A central entity which looks up the requested url for an redirection target.</li>
    <li>Something that will actually redirect the request.</li>
  </ol>
</blockquote>

<h3 id="how-to-redirect">How to redirect?</h3>

<p>We have multiple options for how to redirect a HTTP request. We could either respond with an HTTP <code class="language-plaintext highlighter-rouge">Location</code> header or serve some HTML which would redirect the browser to the actual URL.</p>

<p>Responding with an custom HTTP header would mean, we need to execute some code every time a request comes in. That isn’t stupid or cheap enough. <em>So how could we include a redirection in the HTML file?</em></p>

<p>There are two simple options.</p>

<h5 id="option-1-javascript">Option 1: JavaScript</h5>
<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;html&gt;</span>
    <span class="nt">&lt;head&gt;</span>
        <span class="nt">&lt;title&gt;</span>Redirecting...<span class="nt">&lt;/title&gt;</span>
    <span class="nt">&lt;/head&gt;</span>
    <span class="nt">&lt;script&gt;</span>
        <span class="nb">window</span><span class="p">.</span><span class="nx">location</span><span class="p">.</span><span class="nx">href</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">URL</span><span class="dl">'</span><span class="p">;</span>
    <span class="nt">&lt;/script&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div></div>

<h5 id="option-2-meta-tag">Option 2: Meta Tag</h5>
<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;html&gt;</span>
    <span class="nt">&lt;head&gt;</span>
        <span class="nt">&lt;title&gt;</span>Redirecting...<span class="nt">&lt;/title&gt;</span>
        <span class="nt">&lt;meta</span> <span class="na">http-equiv=</span><span class="s">"refresh"</span> <span class="na">content=</span><span class="s">"0; url=URL"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;/head&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div></div>

<p>Stupid and cheap being our main goal here, <a href="#option-2-meta-tag">Option 2</a> is our way to go. We don’t require some script executions and the browser needs to parse the HTML elements anyway.</p>

<p>Summarized, we only need to serve the correct HTML file, which is the easiest thing to deploy and manage. The actual services we will use will be introduced later.</p>

<h3 id="how-to-map-request-to-target-url">How to map request to target URL?</h3>

<p>We have now resolved the question on how to redirect, but we also need to decide on how we map a requested URL to the specific HTML file. The most simple approach we could use is, encoding the whole requested URL into a filename. This will deliver is an 1:1 mapping of requested url to filename.</p>

<p><em>Which encoding?</em> The encoding everybody uses to encode anything on the web into a safe string. <strong>Base64</strong>. This means, we can map our requests like this:</p>

<table>
  <thead>
    <tr>
      <th>Requested URL</th>
      <th>Filename</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">example.org/abc123/welt</code></td>
      <td><code class="language-plaintext highlighter-rouge">ZXhhbXBsZS5vcmcvYWJjMTIzL3dlbHQK.html</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">something.example.org</code></td>
      <td><code class="language-plaintext highlighter-rouge">c29tZXRoaW5nLmV4YW1wbGUub3JnCg==.html</code></td>
    </tr>
  </tbody>
</table>

<h3 id="handling-traffic">Handling traffic</h3>

<p>As mentioned in <a href="#how-to-redirect">How to redirect?</a> we just need to serve the correct HTML file. <em>But where will the files be stored</em>, <em>how do we serve these files</em> and <em>where will be map the request to the filename?</em> So lets dive right into one way, on how to serve static files via AWS.</p>

<h4 id="storing-the-html-files">Storing the HTML files</h4>

<p>Storing files is very easy to answer even without the AWS Product Page. Amazon S3.<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup> We have a lot of flexibility on how the access is managed and how files will stored/moved and much more.</p>

<h4 id="serving-the-html-files">Serving the HTML files</h4>

<p>Serving static files is made easy thanks to AWS Cloudfront.<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote" rel="footnote">4</a></sup> We can quickly setup custom Domains, SSL certificates and serve files out of S3 buckets.</p>

<h4 id="mapping-request-to-filename">Mapping request to filename</h4>

<p>The connection between an AWS Cloudfront instance and an S3 buckets consists of 4 different event types.</p>

<ul>
  <li><strong>Viewer request</strong>: The request that describes the incoming traffic to cloudfront directly.</li>
  <li><strong>Viewer response</strong>: The response right before it will be sent to the client.</li>
  <li><strong>Origin request</strong>: The request behind Cloudfront to its origin, if there is a cache miss.</li>
  <li><strong>Origin response</strong>: The response of the origin, before it is handled by Cloudfront.</li>
</ul>

<p>The event interesting to us is the <strong>Origin request</strong> event. At this stage Cloudfront doesn’t know what to serve and requires a new mapping of the request to an target filename in our S3 bucket.</p>

<h2 id="implementation">Implementation</h2>

<p><img src="/assets/posts/cheap-and-stupid-aws-urlshortener/infrastructure.svg" alt="" /></p>

<blockquote>
  <p><strong>NOTE</strong>: This post intends to show what is possible with AWS Lambda and Cloudfront. If any information is outdated or actions you do based on this post cause any harm (finacially or in any other way) I’m not responsible.</p>
</blockquote>

<h3 id="s3-bucket">S3 Bucket</h3>

<p><img src="/assets/posts/cheap-and-stupid-aws-urlshortener/create_s3_bucket.png" alt="" /></p>

<p>We don’t need to change anything else in the default options of the bucket settings. Just pick a name an region that suits you.</p>

<h3 id="lambdaedge">Lambda@Edge</h3>

<p>Our mapping from the request to the specific base64 filename will be done with a Lambda function. To be exact an Lambda@Edge function. This difference is very important, as Cloudfront in the next section, will only allow Lambda@Edge functions due to the deployment region.</p>

<p>For this, change you AWS region to <code class="language-plaintext highlighter-rouge">us-east-1</code>, the global AWS region. Here you will open Lambda and create a new Lambda function that will accept our cloudfront requests.</p>

<p><img src="/assets/posts/cheap-and-stupid-aws-urlshortener/create_lambda_function_1.png" alt="" /></p>

<p>Now jump into the Lambda editor and use the following code and click Deploy!</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>

<span class="c1">// Some helper functions from StackOverflow</span>
<span class="kd">const</span> <span class="nx">pointsToFile</span> <span class="o">=</span> <span class="nx">uri</span> <span class="o">=&gt;</span> <span class="sr">/</span><span class="se">\/[^/]</span><span class="sr">+</span><span class="se">\.[^/]</span><span class="sr">+$/</span><span class="p">.</span><span class="nf">test</span><span class="p">(</span><span class="nx">uri</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">hasTrailingSlash</span> <span class="o">=</span> <span class="nx">uri</span> <span class="o">=&gt;</span> <span class="nx">uri</span><span class="p">.</span><span class="nf">endsWith</span><span class="p">(</span><span class="dl">'</span><span class="s1">/</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">needsTrailingSlash</span> <span class="o">=</span> <span class="nx">uri</span> <span class="o">=&gt;</span> <span class="o">!</span><span class="nf">pointsToFile</span><span class="p">(</span><span class="nx">uri</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nf">hasTrailingSlash</span><span class="p">(</span><span class="nx">uri</span><span class="p">);</span>

<span class="nx">exports</span><span class="p">.</span><span class="nx">handler</span> <span class="o">=</span> <span class="p">(</span><span class="nx">event</span><span class="p">,</span> <span class="nx">context</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="c1">// Extract the request from the CloudFront event that is sent to Lambda@Edge </span>
    <span class="kd">let</span> <span class="nx">request</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">Records</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">cf</span><span class="p">.</span><span class="nx">request</span><span class="p">;</span>

    <span class="k">try</span> <span class="p">{</span>
        <span class="c1">// Extract the URI and query string from the request</span>
        <span class="kd">const</span> <span class="nx">hostname</span> <span class="o">=</span> <span class="nx">request</span><span class="p">.</span><span class="nx">headers</span><span class="p">.</span><span class="nx">host</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">value</span><span class="p">;</span>
        <span class="kd">let</span> <span class="nx">uri</span> <span class="o">=</span> <span class="nx">request</span><span class="p">.</span><span class="nx">uri</span><span class="p">;</span>

        <span class="c1">// Extend trailing slash if not present</span>
        <span class="k">if </span><span class="p">(</span><span class="nf">needsTrailingSlash</span><span class="p">(</span><span class="nx">uri</span><span class="p">))</span> <span class="p">{</span>
            <span class="nx">uri</span> <span class="o">+=</span> <span class="dl">'</span><span class="s1">/</span><span class="dl">'</span>
        <span class="p">}</span>

        <span class="c1">// Base64 encode</span>
        <span class="kd">const</span> <span class="nx">newUri</span> <span class="o">=</span> <span class="nx">Buffer</span><span class="p">.</span><span class="k">from</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="nx">hostname</span><span class="p">}${</span><span class="nx">uri</span><span class="p">}</span><span class="s2">`</span><span class="p">).</span><span class="nf">toString</span><span class="p">(</span><span class="dl">'</span><span class="s1">base64</span><span class="dl">'</span><span class="p">);</span>

        <span class="c1">// Assign new uri</span>
        <span class="nx">request</span><span class="p">.</span><span class="nx">uri</span> <span class="o">=</span> <span class="s2">`/</span><span class="p">${</span><span class="nx">newUri</span><span class="p">}</span><span class="s2">.html`</span><span class="p">;</span>

        <span class="c1">// Change host header to origin header, else S3 fails</span>
        <span class="nx">request</span><span class="p">.</span><span class="nx">headers</span><span class="p">.</span><span class="nx">host</span> <span class="o">=</span> <span class="p">[{</span><span class="dl">"</span><span class="s2">key</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Host</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">value</span><span class="dl">"</span><span class="p">:</span> <span class="nx">request</span><span class="p">.</span><span class="nx">origin</span><span class="p">.</span><span class="nx">s3</span><span class="p">.</span><span class="nx">domainName</span><span class="p">}]</span>
    <span class="p">}</span> <span class="k">catch </span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nf">error</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// Return to CloudFront</span>
    <span class="k">return</span> <span class="nf">callback</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">request</span><span class="p">);</span>

<span class="p">};</span>
</code></pre></div></div>

<p>With this done, we can prepare our Cloudfront Distribution,</p>

<h3 id="cloudfront">Cloudfront</h3>

<h4 id="cache-policy">Cache Policy</h4>

<p>As Cloudfront caches as much as it can, we need to tweak the default policy to support the correct handling of subdomains. For that, jump into the side menu and open “Policies” and create a new policy.</p>

<p>Just give it a good name and add the <code class="language-plaintext highlighter-rouge">Host</code> header to the “Cache key settings”.</p>

<p><img src="/assets/posts/cheap-and-stupid-aws-urlshortener/create_cloudfront_policy.png" alt="" /></p>

<blockquote>
  <p><strong>Explanation</strong>: If we don’t add the host header to the caching policy, only the main domain will be used for the cache. Which means, if <code class="language-plaintext highlighter-rouge">example.org/hallo</code> is called first, <code class="language-plaintext highlighter-rouge">sub.example.org/hallo</code> will be resolved to the same cached content.</p>

  <p><em>Don’t ask, how I learned that…</em></p>
</blockquote>

<h4 id="distribution">Distribution</h4>

<p><img src="/assets/posts/cheap-and-stupid-aws-urlshortener/create_cloudfront_distribution_1.png" alt="" /></p>

<p>As the origin domain, select the S3 Bcuket you’ve just created. As we made it a private bucket with strict policies (the default options), we need to allow Cloudfront access to that specific S3 bucket. For that, we can simply choose “Yes use OAI” and use “Create new OAI” to automatically create the required access rights. <strong>Don’t forget</strong> to choose “Yes, update the bucket policy”, else the policiy exists but hasn’t been registered within that bucket.</p>

<p><img src="/assets/posts/cheap-and-stupid-aws-urlshortener/create_cloudfront_distribution_2.png" alt="" />
In order to make caching work correctly, we select our previously created custom Caching Policy. Additionally, we <strong>require</strong> to known the host that is called to resolve the full request url including the full domain. For that we simply use the “AllViewer” policy.</p>

<p><img src="/assets/posts/cheap-and-stupid-aws-urlshortener/create_cloudfront_distribution_3.png" alt="" />
Now the only main thing left for the shortener is, to select our Lambda function we have created before. The “Function ARN/Name” can be found in the Lambda function details and just needs to be copied.</p>

<p>Additionally, I recommend to select “Redirect HTTP to HTTPS” add your own custom CNAME and Custom SSL certificate in combination with Route53.<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote" rel="footnote">5</a></sup> Moreover, using “Error pages” in the Cloudfront Distibution settings is recommended. Simply redirect <code class="language-plaintext highlighter-rouge">403</code> and <code class="language-plaintext highlighter-rouge">404</code> to <code class="language-plaintext highlighter-rouge">/</code> which will than resolve via the Lambda function to the base64 code of your root domain.</p>

<p>Now you can click <strong>Create distribution</strong>.</p>

<h2 id="workflow-for-new-urls">Workflow for new urls</h2>

<p>As we didn’t require any interface for registering any new urls, we can simply create a new HTML file with a bash script and upload it to the bucket with the AWS cli. In the real world, something like an Slack Bot or similar that uses an Lambda function would a good way to register new URLs with an random id, like <code class="language-plaintext highlighter-rouge">example.org/abc123</code>.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/usr/bin/env bash</span>

<span class="nv">SOURCE</span><span class="o">=</span><span class="nv">$1</span>
<span class="nv">TARGET</span><span class="o">=</span><span class="nv">$2</span>

<span class="nv">HTML</span><span class="o">=</span><span class="s2">"&lt;html&gt;
    &lt;head&gt;
        &lt;meta http-equiv=</span><span class="se">\"</span><span class="s2">refresh</span><span class="se">\"</span><span class="s2"> content=</span><span class="se">\"</span><span class="s2">0; url=</span><span class="nv">$TARGET</span><span class="se">\"</span><span class="s2"> /&gt;
    &lt;/head&gt;
&lt;/html&gt;"</span>

<span class="nv">HASH</span><span class="o">=</span><span class="si">$(</span><span class="nb">echo</span> <span class="nt">-ne</span> <span class="s2">"</span><span class="nv">$SOURCE</span><span class="s2">"</span> | <span class="nb">base64</span><span class="si">)</span>
<span class="nv">FILEPATH</span><span class="o">=</span><span class="s2">"</span><span class="si">$(</span><span class="nb">dirname</span> <span class="nv">$0</span><span class="si">)</span><span class="s2">/</span><span class="k">${</span><span class="nv">HASH</span><span class="k">}</span><span class="s2">.html"</span>

<span class="nb">echo</span> <span class="s2">"</span><span class="nv">$HTML</span><span class="s2">"</span> <span class="o">&gt;</span> <span class="nv">$FILEPATH</span>
aws s3 <span class="nb">cp</span> <span class="nv">$FILEPATH</span> s3://urlshortener/
</code></pre></div></div>

<p>If you want to replace an existing shortned URL, you also need to invalidate the Cloudfront cache before the change takes effect.<sup id="fnref:6" role="doc-noteref"><a href="#fn:6" class="footnote" rel="footnote">6</a></sup></p>

<h2 id="costs">Costs</h2>

<p>Lets assume some traffic stuff. Every registered URL is requested 10000 times a month and we have 1000 registered URLs. Additionally, we <strong>exclude the free tier</strong> for full price transparency.</p>

<blockquote>
  <p>Pricing data from <code class="language-plaintext highlighter-rouge">2021-12-13</code>.</p>
</blockquote>

<h4 id="costs-lambdaedge">Costs Lambda@Edge</h4>

<p>Our Lambda function takes <code class="language-plaintext highlighter-rouge">2ms</code> to respond if hot. But let us assume the worst case with <code class="language-plaintext highlighter-rouge">100ms</code> on average. We only require the minimum RAM requirement <code class="language-plaintext highlighter-rouge">128MB</code>.</p>

<p>Which means using the AWS calculator<sup id="fnref:7" role="doc-noteref"><a href="#fn:7" class="footnote" rel="footnote">7</a></sup>:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1,000 requests x 100 ms x 0.001 ms to sec conversion factor = 100.00 total compute (seconds)
0.125 GB x 100.00 seconds = 12.50 total compute (GB-s)
12.50 GB-s x 0.00005001 USD = 0.00 USD (monthly compute charges)
1,000 requests x 0.0000006 USD = 0.00 USD (monthly request charges)
Lambda@Edge costs (monthly): 0.0006 USD
</code></pre></div></div>

<h4 id="costs-s3">Costs S3</h4>

<p>Our HTML template file without the target URL itself consumes <code class="language-plaintext highlighter-rouge">98bytes</code>. An Google Drive target URL requires about <code class="language-plaintext highlighter-rouge">103bytes</code>. So we have <code class="language-plaintext highlighter-rouge">1000 URLs * (98bytes + 103bytes) = 196000 bytes = 196kB</code>. Additionally we have 1000 PUT, COPY, POST, LIST  requests and 1000 GET, SELECT requests and return the stored storage once thanks to the caching of cloudfront.</p>

<p>Which means using the AWS calculator<sup id="fnref:7:1" role="doc-noteref"><a href="#fn:7" class="footnote" rel="footnote">7</a></sup>:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Tiered price for: 0.000196 GB
0.000196 GB x 0.0230000000 USD = 0.00 USD
Total tier cost = 0.0000 USD (S3 Standard storage cost)
1,000 PUT requests for S3 Storage x 0.000005 USD per request = 0.005 USD (S3 Standard PUT requests cost)
1,000 GET requests in a month x 0.0000004 USD per request = 0.0004 USD (S3 Standard GET requests cost)
0.000196 GB x 0.0007 USD = 0.00 USD (S3 select returned cost)
0.0004 USD + 0.005 USD = 0.01 USD (Total S3 Standard Storage, data requests, S3 select cost)
S3 Standard cost (monthly): 0.01 USD
</code></pre></div></div>

<h4 id="costs-cloudfront">Costs Cloudfront</h4>

<p>Assuming we only send traffic to Europe, all saved URls will be called 10000times, which means we serve <code class="language-plaintext highlighter-rouge">195kB * 10000requests = 1.96GB</code> of data with a total of 10000000 requests.</p>

<p>Which means using the AWS calculator<sup id="fnref:7:2" role="doc-noteref"><a href="#fn:7" class="footnote" rel="footnote">7</a></sup>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Tiered price for: 1.96 GB
1.96 GB x 0.0850000000 USD = 0.17 USD
Total tier cost = 0.17 USD (Data transfer out to internet from Europe)
Data transfer out to internet cost: 0.17 USD
Data transfer out to origin cost: 0 USD
10,000,000 requests x 0.0000012 USD = 12.00 USD (HTTPS requests from Europe)
Requests cost: 12.00 USD
0.17 USD + 12.00 USD = 12.17 USD (Total cost Europe)
CloudFront price Europe (monthly): 12.17 USD
</code></pre></div></div>

<h4 id="costs-summary">Costs summary</h4>

<p>Which means, we have a monthly total of <code class="language-plaintext highlighter-rouge">12.18USD</code> <strong>if we don’t use the free tier</strong>. If we do, we pay nothing as Cloudfront has a huge Free tier since <code class="language-plaintext highlighter-rouge">2021-12-01</code> with 1TB free traffic and 10million free requests. Our S3 usage is so low, it is covered by the free tier anyway and the Lambda@Edge costs are somewhere in the less than 1cent region.</p>

<h2 id="summary">Summary</h2>

<p><em>Should you do this?</em> … <strong>Definitely not.</strong> Search for an existing service that also includes an fancy web interface and don’t waste hours trying to make something fit, it wasn’t designed for. But this is a great way of learning how you can combine Lambda@Edge with Cloudfront to create something new.</p>

<!-- Footnotes -->
<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>AWS products page: <a href="https://aws.amazon.com/products">https://aws.amazon.com/products</a> <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>“The 17 Ways to Run Containers on AWS” by Corey Quinn at LastWeekInAWS: <a href="https://www.lastweekinaws.com/blog/the-17-ways-to-run-containers-on-aws/">https://www.lastweekinaws.com/blog/the-17-ways-to-run-containers-on-aws</a> <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>Amazon S3 Product Page: <a href="https://aws.amazon.com/s3">https://aws.amazon.com/s3</a> <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>Amazon Cloudfront Product Page: <a href="https://aws.amazon.com/cloudfront">https://aws.amazon.com/cloudfront</a> <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p>AWS Documentation “Using custom URLs by adding alternate domain names (CNAMEs)”: <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/CNAMEs.html">https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/CNAMEs.html</a> <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:6" role="doc-endnote">
      <p>AWS Documentation: “Invalidating Files”: <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Invalidation.html">https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Invalidation.html</a> <a href="#fnref:6" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:7" role="doc-endnote">
      <p>AWS Calculator: <a href="https://calculator.aws/">https://calculator.aws</a> <a href="#fnref:7" class="reversefootnote" role="doc-backlink">&#8617;</a> <a href="#fnref:7:1" class="reversefootnote" role="doc-backlink">&#8617;<sup>2</sup></a> <a href="#fnref:7:2" class="reversefootnote" role="doc-backlink">&#8617;<sup>3</sup></a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="aws" /><summary type="html"><![CDATA[How cheap and low-tech can we make an URL shortener?]]></summary></entry><entry><title type="html">Counting Instead of Tracking</title><link href="https://oltdaniel.eu/blog/2018/counting-instead-of-tracking.html" rel="alternate" type="text/html" title="Counting Instead of Tracking" /><published>2018-11-15T00:00:00+01:00</published><updated>2018-11-15T00:00:00+01:00</updated><id>https://oltdaniel.eu/blog/2018/counting-instead-of-tracking</id><content type="html" xml:base="https://oltdaniel.eu/blog/2018/counting-instead-of-tracking.html"><![CDATA[<p>Analyzing the traffic a website receives, is a key part in marketing to
understand and highlight the group of consumers and their interests. However,
the way how it has been implemented in the recent years has evolved from
counting single requests to tracking the use across multiple websites.</p>

<p>For a short moment I decided against this trend and went back to the old
classics of website analysis. I start counting the unique requests, instead of
tracking the user across our website. You may ask yourself now, what the
motivation behind this solution is. First, I hate cookie banners. Every site
we will request, will have an huge cookie banner explaining how our data will
be used on the current site I am viewing. Secondly, I love minimalistic
solutions that will solve our problem in just a view lines of code.</p>

<p>Therefore, I will follow certain rules in our solution in order to deliver a
minimalistic, and privacy protective solution to the user devices with a low
bandwidth usage. How I will receive the visitors data is limited to a simple
resource loading procedure by the browser, which means, I will not use
JavaScript in order to collect and send the data that is required on the server
side. Additionally, our solution is not allowed to store data on the client
device, e.g. cookies, as I do not want to have any kind of cookie banner on our
website.</p>

<ol>
  <li>No JavaScript is allowed, the data needs to be sent by the browser itself.</li>
  <li>As of 1., I am not able to extract any extra information from the client
device and are limited to the HTTP request only.</li>
  <li>A low bandwidth will be automatically achieved, as I do not need to send
any return body, nor is the server required to send any scripts to the client
that are responsible for the data collection and sending procedure.</li>
</ol>

<h3 id="meta-data">Meta-data</h3>

<p>The way of making the request is now done. But I need to decided on the
information I will extract from the HTTP headers or can be extracted from the
raw TCP request behind the HTTP protocol. This can be classified as meta-data.
As I specified in the goal before, I do not want to store that kind of data as
raw data on our server. However, I need some visitor specific data, that I can
use in order to identify a unique user.</p>

<p>Storing an random unique id on the user device as an cookie would have many
advantages at this point, as it will allow us to be completely independent from
the user meta-data and count unique page views as long as the cookie is not
expired. However, I hate cookie banners, so on this kind of solution violates
the rule of our solution.</p>

<ul>
  <li><strong>Referer</strong>: The Referer HTTP header will be delivered with the root url
the user requested, of which the received request on our server is a subordinate
request.</li>
  <li><strong>IP address</strong>: Each request will be started by a visitors device having an
IP address. I will use this, in order to identify the users device with an
unique value.</li>
  <li><strong>User-Agent</strong>: Multiple browsers are available on the market with
different versions and browser engines. As this setting is not totally unique,
it needs to be combined with another information.</li>
</ul>

<h3 id="storing-data">Storing data</h3>

<p>Having specified the data I am able to extract from the HTTP request, I need
to combine this data, in order to be privacy protective and unique. Another
aspect I need to add at this point, is the fact I do not want to store these
informations in raw format on our server.</p>

<p>Lets start with the privacy protective part, that I want in our solution. The
data that is privacy relevant in the meta-data I have collect within the HTTP
request is the IP address. A way of partly anonymizing it is removing the last
part of the IP address, e.g. <code class="language-plaintext highlighter-rouge">1.1.1.1</code> will become <code class="language-plaintext highlighter-rouge">1.1.1</code>.<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup> This procedure is also known as IP masking. This
will merge 256 different IP addresses to the same id, but 256 of 2^32 isn’t that
much. However doing this will rise the privacy level.</p>

<p>More privacy means less uniqueness in the most cases, if nothing will be stored
on the client device in order to represent an identity. This is a common problem
with using a single value as an identifier. So let us try merging multiple
values together.</p>

<p>Looking back into the list of meta-data I have collected from the HTTP request,
we can use the <code class="language-plaintext highlighter-rouge">User-Agent</code> header in order to rise the level of uniqueness we
slightly shrank in the last step. By merging the reaming IP address and the
user agent of the specific user, I assigned a specific browser to a specific
client. A partly unique IP address and a partly unique browser user agent give
us way more combinations, and so on, an higher level of uniqueness.</p>

<p>So far, so good. I assigned a unique id to a specific user. However, I need
the root url, in order to identify the page that has been originally requested.
This can be easily done, as a resource request of the browser - in this case for
an image tag - adds a <code class="language-plaintext highlighter-rouge">Referer</code> HTTP header, which contains the url of the page
that has been originally visited. As I have only a single domain, I can reduce
this url to the path only, instead of the full url. I do not care about the
query a user can choose, as this will allow him to generate an infinite amount
of page views and unique request ids. Each request id belongs to one specific
path and one specific user.</p>

<p>Adding the path to the hash allows the user to be even more anonymous, as the
server can only identify whether he has called the same url twice (matching
request ids) or not. Without the request hash, tracking across the paths is
possible and the privacy shrinks.</p>

<p>The solution to the last step, hiding the actual information behind the unique
data, is hashing it. The id is then only reversible by brute-forcing every
possible input, which would be useless at this point, as the IP address it not
stored in full length in the unique data and who cares about the user agent.</p>

<p>Summarized, our request id will be a hash of a partially IP address, the
user agent and the path that has been originally requested.</p>

<h3 id="code">Code</h3>

<p>The solution is now defined. A possible implementation can be found below
written in Ruby. Please note, that the provided solution is not production ready
and has no persistent storage. If this kind of concept should be moved to
production, it is suggested to add a database server, taking care of the unique
request ids. However, a cuckoo filter - or other filters - as this will filter
out same requests in order to lower the database server usage.</p>

<p>If this functionality will be abused by other websites, the code will
automatically reject those requests by checking the domain of the <code class="language-plaintext highlighter-rouge">Referer</code>
header.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'sinatra'</span>
<span class="nb">require</span> <span class="s1">'cuckoo_filter'</span>

<span class="nb">require</span> <span class="s1">'uri'</span>
<span class="nb">require</span> <span class="s1">'digest'</span>

<span class="n">set</span> <span class="ss">:port</span><span class="p">,</span> <span class="mi">3001</span>

<span class="c1"># In order to identify unique requests</span>
<span class="n">filter</span> <span class="o">=</span> <span class="no">CuckooFilter</span><span class="p">.</span><span class="nf">make</span><span class="p">(</span><span class="ss">size: </span><span class="mi">10_000</span><span class="p">)</span>
<span class="c1"># Final statistics</span>
<span class="n">counts</span> <span class="o">=</span> <span class="no">Hash</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="n">get</span> <span class="s1">'/image.jpg'</span> <span class="k">do</span>
  <span class="n">content_type</span> <span class="s1">'image/jpg'</span>
  <span class="c1"># Referer must be given</span>
  <span class="k">return</span> <span class="k">if</span> <span class="n">request</span><span class="p">.</span><span class="nf">referer</span><span class="p">.</span><span class="nf">nil?</span>
  <span class="n">url</span> <span class="o">=</span> <span class="no">URI</span><span class="p">(</span><span class="n">request</span><span class="p">.</span><span class="nf">referer</span><span class="p">)</span>
  <span class="c1"># Root referer host is required</span>
  <span class="k">return</span> <span class="k">unless</span> <span class="n">url</span><span class="p">.</span><span class="nf">host</span> <span class="o">==</span> <span class="s1">'fcused.at'</span>
  <span class="c1"># Remove last ip address block</span>
  <span class="n">ip</span> <span class="o">=</span> <span class="n">request</span><span class="p">.</span><span class="nf">ip</span><span class="p">[</span><span class="mi">0</span><span class="o">...</span><span class="n">request</span><span class="p">.</span><span class="nf">ip</span><span class="p">.</span><span class="nf">rindex</span><span class="p">(</span><span class="s1">'.'</span><span class="p">)]</span>
  <span class="c1"># Convert meta-data into non-meta-data identifier</span>
  <span class="nb">hash</span> <span class="o">=</span> <span class="no">Digest</span><span class="o">::</span><span class="no">SHA256</span><span class="p">.</span><span class="nf">hexdigest</span> <span class="s2">"</span><span class="si">#{</span><span class="n">ip</span><span class="si">}#{</span><span class="n">request</span><span class="p">.</span><span class="nf">user_agent</span><span class="si">}#{</span><span class="n">url</span><span class="p">.</span><span class="nf">path</span><span class="si">}</span><span class="s2">"</span>
  <span class="c1"># Check if request already exists</span>
  <span class="k">unless</span> <span class="n">filter</span><span class="p">.</span><span class="nf">lookup</span> <span class="nb">hash</span>
    <span class="c1"># Add request if to filter</span>
    <span class="n">filter</span><span class="p">.</span><span class="nf">insert</span> <span class="nb">hash</span>
    <span class="c1"># Increment counts</span>
    <span class="n">counts</span><span class="p">[</span><span class="n">url</span><span class="p">.</span><span class="nf">path</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">get</span> <span class="s1">'/stats'</span> <span class="k">do</span>
  <span class="c1"># Return the current statistics</span>
  <span class="n">counts</span>
<span class="k">end</span>
</code></pre></div></div>

<p>In order to count specific requests on some pages, the following HTML need to be
added.</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;img</span> <span class="na">src=</span><span class="s">"http://localhost:3001/image.jpg"</span> <span class="na">style=</span><span class="s">"display: none;"</span><span class="nt">&gt;</span>
</code></pre></div></div>

<p>This kind of implementation can be applied to any content type. The request
since can be reduced to under 100bytes, meaning there is no time and bandwidth
consumed in web analytics. An example implementation in golang can be found here
<a href="https://github.com/oltdaniel/door">https://github.com/oltdaniel/door</a>.</p>

<h3 id="conclusion">Conclusion</h3>

<p>As an final statement I can say, that the statistics I collect from the
requests and store in our database, deliver enough information to elaborate
facts I can reuse for marketing purposes. Besides, I can say, due to the low
amount of information, I will have a low bandwidth usage and deliver a
minimalistic solution. The privacy aspect I described in the beginning is
simply covered by the hashing of the user id and removing the last block of the
IP address.</p>

<!-- References -->
<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>IP Anonymization in Analytics by Google <a href="https://support.google.com/analytics/answer/2763052">https://support.google.com/analytics/answer/2763052</a> <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="analytics" /><summary type="html"><![CDATA[Analyzing the traffic a website receives, is a key part in marketing to understand and highlight the group of consumers and their interests. However, the way how it has been implemented in the recent years has evolved from counting single requests to tracking the use across multiple websites.]]></summary></entry></feed>